---
layout: post
title: "Android Hacking Part3 : Dynamic Analysis"
date: 2025-08-26
categories: [Android Pentesting,Android Apps,Operating Systems,Mobile Development]
image: https://cdn-images-1.medium.com/max/800/1*59Yk_3Mt9Dkb_vI9JIao5g.jpeg
---

### Dynamic Analysis

is done during running the program.

**How install applications with adb?**

> **adb install apkfilename.apk**

okay, now how intercept traffic of the application?  
**Burp Suite**: Is an integrated platform for performing security testing of web applications. Its various tools work seamlessly together to support the entire testing process, from initial mapping and analysis of an application’s attack surface, through to finding and exploiting security vulnerabilities.

#### [Configure the Burp Proxy listener](https://support.portswigger.net/customer/portal/articles/1841101-configuring-an-android-device-to-work-with-burp)

Installing trusted CA at the Android OS level (Root device/Emulator) for Android N+ as the following:

![](https://cdn-images-1.medium.com/max/800/1*7dlV_aUDOolugFWhfc8AVg.png)

#### [Drozer](https://github.com/FSecureLABS/drozer)

Drozer helps to provide confidence that Android apps and devices being developed by, or deployed across, your organization do not pose an unacceptable level of risk. By allowing you to interact with the Dalvik VM, other apps’ IPC endpoints, and the underlying OS.

Drozer provides tools to help you use and share public exploits for Android. For remote exploits, it can generate shellcode to help you deploy the drozer Agent as a remote administrator tool, with maximum leverage on the device.

Drozer is a comprehensive security audit and attack framework for Android.

#### Basic example: Abusing unprotected activities.

The requirement for this is that you have to install drozer on your computer and drozer agent in your emulator or devices. Click in the title, for the tutorial of how install...

**Commands:**

> **adb forward tcp:31415 tcp:31415**

> **drozer console connect**

Now download and install [**apk**](https://github.com/as0ler/Android-Examples/raw/master/sieve.apk) for this example.

Retrieving package information:

> **run app.package.list** -&gt; see all the packages installed

> **run app.package.info -a** -&gt; view package information.

Identifying the attack surface, activities unprotected, and more.

> **run app.package.attacksurface package\_name**

![](https://cdn-images-1.medium.com/max/800/1*_dv_epNLGdINyTVWcEmnTA.png)

view what activities can be exploited.

> **run app.activity.info -f package\_name**

Start activities unprotected!

> **run app.activity.start — component package name component\_name**

![](https://cdn-images-1.medium.com/max/800/1*A8aTZr_oTkHf27hdoPpgFA.png)

#### **Basic Cheatsheet of Drozer**

Exploiting Content Provider

> **run app.provider.info -a package\_name**

> **run scanner.provider.finduris -a package\_name**

> **run app.provider.query uri**

> **run app.provider.update uri — selection conditions selection\_arg column data**

> **run scanner.provider.sqltables -a package\_name**

> **run scanner.provider.injection -a package\_name**

> **run scanner.provider.traversal -a package\_name**

Exploiting Service

> **run app.service.info -a package\_name**

> **run app.service.start — action action — component package\_name component\_name**

> **run app.service.send package\_name component\_name — msg what arg1 arg2 — extra type key value — bundle-as-obj**

#### Dynamic Analysis — Complications

**Root Detection in Android device:**

My explanation for this is:

> **if(device &amp;&amp; emulator = rooted):**

> **print “app going to the shit!”**

> **else:**

> **print “app found”**

So it is the best way to check in your application whether the device is rooted or not to avoid data theft, but there’s no 100% way to check for root.

**Check for Test-Keys**: Test-Keys has to do with how the kernel is signed when it is compiled. By default, stock Android ROMs from Google are built with release-keys tags. Test-Keys means it is signed with a custom key generated by a third-party developer. Specifically, it will check in build properties(“android.os.Build.TAGS”) for test-keys.

> **private boolean detectTestKeys() {**  
> **String buildTags = android.os.Build.*TAGS*;**  
> **return buildTags != null &amp;&amp; buildTags.contains(“test-keys”);**  
> **}**

**Check for “su” binary**: Su binary check is to identify the superuser in the device. This binary is installed when you try to root your phone using apps like kinguser or via fastboot in Android. These files are necessary so that one can root their phone and become the superuser. The existence of this binary can be checked from the following paths.

> **private boolean checkForSuBinary() {**  
> **return checkForBinary(“su”); *// function is available below***  
> **}**

**Check for “busybox” binary:** If a device has been rooted, more often than not Busybox has been installed as well. Busybox is a binary that provides many common Linux commands. Running busybox is a good indication that a device has been rooted.

> **private boolean checkForBusyBoxBinary() {**  
> **return checkForBinary(“busybox”);*//function is available below***  
> **}**

**Check for SuExists:** different file system check for the su binary.

> **private boolean checkSuExists() {**  
> **Process process = null;**  
> **try {**  
> **process = Runtime.*getRuntime*().exec(new String\[]**  
> **{“/system /xbin/which”, “su”});**  
> **BufferedReader in = new BufferedReader(**  
> **new InputStreamReader(process.getInputStream()));**  
> **String line = in.readLine();**  
> **process.destroy();**  
> **return line != null;**  
> **} catch (Exception e) {**  
> **if (process != null) {**  
> **process.destroy();**  
> **}**  
> **return false;**  
> **}**  
> **}**

The following **paths**, Su and busybox binaries are often looked for on rooted devices.

> **private String\[] binaryPaths= {**  
> **“/data/local/”,**  
> **“/data/local/bin/”,**  
> **“/data/local/xbin/”,**  
> **“/sbin/”,**  
> **“/su/bin/”,**  
> **“/system/bin/”,**  
> **“/system/bin/.ext/”,**  
> **“/system/bin/failsafe/”,**  
> **“/system/sd/xbin/”,**  
> **“/system/usr/we-need-root/”,**  
> **“/system/xbin/”,**  
> **“/system/app/Superuser.apk”,**  
> **“/cache”,**  
> **“/data”,**  
> **“/dev”**  
> **};**

**Emulator Detection:**

My explanation for this is:

> **if(isEmulator):**

> **print “app going to the shit!”**

> **else:**

> **print “app found”**

First you need to check the the pre-decompiled source code and check for functions that contains strings like “generic | emulator | google\_sdk” and functions like “isEmulator | emulatorDetection…etc” … use your searching skills and read the code well.

**SSL Pinning:**

Is a technique that we use in the client side to avoid man-in-the-middle attack by validating the server certificates again even after SSL handshaking. The developers embed (or pin) a list of trustful certificates to the client application during development, and use them to compare against the server certificates during runtime. If there is a mismatch between the server and the local copy of certificates, the connection will simply be disrupted, and no further user data will be even sent to that server. This enforcement ensures that the user devices are communicating only to the dedicated trustful servers.

![](https://cdn-images-1.medium.com/max/800/1*Rs8yWxSHdCx2pQLnqJlRkw.png)

After you have taken in the illustration above, note that certificate pinning attempts to ensure that the client is not exchanging messages with any other server than the one they hold a public key for. Therefore, the client is not exposed to attacks where a rogue Certificate Authority (CA) validates the authenticity of a malicious host serving content with a sham certificate.

> **if(devices &amp;&amp; emulators = CA\_BURPSUITE):**

> **print “not intercept comunications ):”**

> **else:**

> **print “App found”**

#### **Hooking applications**:

Techniques used to alter the behavior of applications.

**Frida**

In short, it is a dynamic instrumentation framework, which enables function hooking and allows to provide a definition to it during runtime. Basically, it injects JavaScript code into a process. Suppose, there is a function called “foo” in a program with a specific body/implementation. Using “Frida”, one can change the body/implementation of the “foo” function during runtime. “Frida” supports a variety of platforms like Windows, macOS, GNU/Linux, iOS, Android, and QNX. More information on “Frida” can be found [here](https://www.frida.re/docs/home/).

for install

`pip install frida-tools`

Now check version and download the server, in my case is 12.6.8

`frida --version`

unzip file and push the server in the local system /data/local/tmp

`adb push /path/serverfrida /data/local/tmp`

Permissions

`adb shell chmod 777 /data/local/tmp/frida-server`

run frida server

**adb shell /data/local/tmp/frida-servername&amp;**

now execute in your command line **frida-ps -U**

[**Bypass SSL pinning tutorial**](https://medium.com/@ved_wayal/hail-frida-the-universal-ssl-pinning-bypass-for-android-e9e1d733d29)

Now your turn is to practice more and more. This [**link**](https://github.com/DERE-ad2001/Frida-Labs) has more labs on frida and hooking technique. Happy Hacking!

By [Moataz Osama](https://medium.com/@mezo512) on [February 26, 2025](https://medium.com/p/997c5c66a45c).

[Canonical link](https://medium.com/@mezo512/android-hacking-part3-dynamic-analysis-997c5c66a45c)

Exported from [Medium](https://medium.com) on August 26, 2025.